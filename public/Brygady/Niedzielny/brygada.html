<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.4">
    <link rel="stylesheet" href="../../style_css/headermenu.css">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="refresh" content="180">
    <title>Szczegóły kursu</title>
    <style>
        body {
            background: rgb(50, 50, 50);
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            color: white;
        }

        h1 {
            font-size: 2rem;
            margin: 40px 0 10px;
        }

        table {
            width: 90%;
            max-width: 940px;
            border-collapse: collapse;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 20px;

        }

        th,
        td {
            text-align: center;
            padding: 10px;
            border: 1.5px solid #ccc;
            font-size: 17px;
        }


        thead {
            background-color: rgba(163, 120, 0);
        }

        .NrOflp {
            text-decoration: none;
            color: orange;
        }

        .hide {
            font-size: 0px;
            padding: 0px;
            border: 0px;
        }

        .Rez {
            padding: 0px;
            text-align: right;
            border-top: 1px solid;
            border-bottom: 1px solid;
            border-left: none;
            border-right: none;

        }

        .RezLP {
            padding: 0px;
            text-align: right;
            border-top: 1px solid;
            border-bottom: 1px solid;
            border-left: 1px solid;
            border-right: none;
        }

        p {
            color: grey;
        }

        #brygadaType {
            margin-top: -5px;
            color: grey;
        }

        #wykazbrygady {
            width: 30%;
        }

        header {
            position: sticky;
            top: 0px;
            background-color: rgb(50, 50, 50);
        }

        @keyframes blink {
            0% {
                background-color: red;
            }

            50% {
                background-color: transparent;
            }

            100% {
                background-color: red;
            }
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blinkbrake {
            0% {
                background-color: transparent 20%;
            }

            50% {
                background-color: transparent;
            }

            100% {
                background-color: transparent 20%;
            }
        }

        .blinkbrake {
            animation: blinkbrake 2s infinite;
        }

        .BrakeDetected {
            color: white;
            pointer-events: visible;
        }

        .NoBrakeDetected {
            color: grey;
            pointer-events: none;
        }

        .PodmianaDetected {
            color: white;
            pointer-events: visible;
        }

        .NoPodmianaDetected {
            color: grey;
            pointer-events: none;
        }

        .highlightButton {
            color: white;
            pointer-events: visible;
        }

        .NohighlightButton {
            color: grey;
            pointer-events: none;
        }

        .PTDetected {
            color: white;
            pointer-events: visible;
        }

        .NoPTDetected {
            color: grey;
            pointer-events: none;
        }

        .buttons a {
            width: 170px;
            text-align: center;
        }

        .WNLZDZDetected {
            color: white;
            pointer-events: visible;
        }

        .NoWNLZDZDetected {
            color: grey;
            pointer-events: none;
        }

    </style>
</head>

<body>
    <header>
        <a href="../../Main_Panel.html" class="menu">Panel Główny</a>
        <a href="../../Przystanki/listaprzystankow.html" class="menu">Przystanki</a>
        <a href="../ChooseDay.html" class="menu">Brygady</a>
        <a href="../../Brygady/Kursy/Kursy.html" class="menu">Kursy</a>
        <a href="../../Pojazdy_Live/PojazdyLIVE.html" class="menu">Pojazdy LIVE</a>
        <a href="#" class="menu exit" id="logout">Opuść Panel</a>
        <hr>
    </header>

    <h1 id="brygadaTitle">Brygada</h1>
    <h3 id="pojazdlive" style="margin: -5px 0px 8px 0px;">Autobus zalogowany do brygady: ...</h3>
    <h3 id="brygadaType"></h3>

    <div class="buttons">
        <a href="#" class="menu" id="highlightButton">Wyróżnij linie</a>
        <a href="#" class="menu" id="highlitghtedButton">Wyłącz podświetlenie</a>
        <br>
        <a href="#" class="menu" id="przerwaButton">Ukryj przerwę</a>
        <a href="#" class="menu" id="podmianaButton">Ukryj podmianę</a>
        <br>
        <a href="#" class="menu" id="PTButton">Ukryj PT</a>
        <a href="#" class="menu" id="WNLZDZButton">Ukryj WNL i ZDZ</a>
        <br>
    </div>
    <a href="#" class="menu PrzerwaBisowa" id="PBButton" style="display: none;">Ukryj Przerwę Bisową</a>

    <table id="awykazstrony" style="width: 90%; display: none;">
        <thead>
            <tr>
                <th>Numer Autobusu</th>
                <th>Brygada</th>
                <th style="display: none;">Model Autobusu</th>
                <th>Opóźnienie</th>
                <th>Numer Linii</th>
                <th>Kierunek</th>
                <th style="display: none;">Następny kierunek</th>
                <th>Godzina odjazdu</th>
            </tr>
        </thead>
        <tbody id="dane-wykaz">
            <!-- Wiersze zostaną dodane automatycznie -->
        </tbody>
    </table>

    <table id="wykazbrygady">
        <thead>
            <tr>
                <th>Zmiana</th>
                <th>Godz. Rozp.</th>
                <th>Godz. Zak.</th>
                <th>Czas</th>
                <th style="display: none;">Km</th>
            </tr>
        </thead>
        <tbody id="dane-wykaz">
            <!-- Rows will be added dynamically -->

        </tbody>
    </table>
    <br>

    <dir>
        <table id="rozkładTable">
            <thead>
                <tr>
                    <th>Lp</th>
                    <th>Linia</th>
                    <th>Początek</th>
                    <th>Kierunek</th>
                    <th>Godz. Rozp.</th>
                    <th>Godz. Zak.</th>
                    <th>Czas trwania</th>
                    <th style="display: none;">Km</th>
                    <th class="hide">Kod Trasy</th>
                    <th class="hide">Kod Linii</th>
                </tr>
            </thead>
            <tbody id="dane-tabeli">
                <!-- Rows will be added dynamically -->
            </tbody>
        </table>
        <p class="top" style="margin-top: 5px; ">Brygada ważna od <span id="waznyOd">ładowanie...</span></p>

    </dir>

    <!--<button onclick="drukujRozklad()">Drukuj rozkład</button>-->

    <p>Strona odświeża się automatycznie co 180 sekund.</p>

    <script>
        let ChoosedTypeOfRozklad = localStorage.getItem("ChoosedTypeOfRozklad");
        let Miasto = localStorage.getItem('Miasto');

        // Check if the user is logged in, otherwise redirect
        function checkLogin() {
            const user = JSON.parse(localStorage.getItem('user'));
            if (!user) {
                window.location.href = '../../zoltakartka.html';
            }
        }

        // Set the title for the brigade
        function loadBrygadaTitle() {
            const brygadaTitle = sessionStorage.getItem('brygadaTitle');
            if (brygadaTitle) {
                const formattedTitle = brygadaTitle.replace(/_/g, '/');
                document.getElementById('brygadaTitle').innerText = `Szczegóły brygady: ${formattedTitle}`;
            } else {
                console.error("Nie znaleziono brygadaTitle w sessionStorage.");
            }
        }

        function loadBrygadaType() {
            const brygadaType = sessionStorage.getItem('BrygadaType');
            console.log('loadBrygadaType, brygadaType:', brygadaType);

            const tbody = document.getElementById('dane-wykaz');
            if (!tbody) {
                console.error('Nie znaleziono elementu tbody o id "dane-wykaz"');
                return;
            }

            if (brygadaType) {
                document.getElementById('brygadaType').innerText = brygadaType;
            } else {
                console.error("Nie znaleziono brygadaTitle w sessionStorage.");

                // Wyczyść istniejące wiersze
                tbody.innerHTML = '';

                // Stwórz scalony wiersz z komunikatem
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.setAttribute('colspan', '5');
                cell.style.textAlign = 'center';
                cell.style.fontStyle = 'italic';
                cell.textContent = 'Brak danych o typie brygady.';

                row.appendChild(cell);
                tbody.appendChild(row);
            }
        }


        // Logout logic
        document.getElementById('logout').addEventListener('click', function() {
            localStorage.clear();
            window.location.href = '../../index.html';
        });

        // Fetch the 'GOTOWE.txt' file
        async function fetchGOTOWEFile() {
            const brygadaTitle = sessionStorage.getItem('brygadaTitle');
            if (!brygadaTitle) {
                console.error("Nie znaleziono brygadaTitle w sessionStorage.");
                return null;
            }


            let filePath = `../../../Brygady/${Miasto}/WYNIKI/Gotowe_brygady/${ChoosedTypeOfRozklad}/${brygadaTitle}/GOTOWE.txt`;
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`Sieć odpowiedziała błędem: ${response.status}`);
                }
                const text = await response.text();
                return text.split("\n");
            } catch (error) {
                console.error('Błąd podczas odczytu pliku GOTOWE.txt:', error);
                return null;
            }
        }

        // Fetch the 'Kierunki.txt' file
        async function fetchKierunkiFile() {
            const filePath = `../../../Brygady/${Miasto}/WYNIKI/Kierunki.txt`;

            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`Sieć odpowiedziała błędem: ${response.status}`);
                }
                const text = await response.text();
                return text.split("\n");
            } catch (error) {
                console.error('Błąd podczas odczytu pliku Kierunki.txt:', error);
                return null;
            }
        }

        // Build a map from the Kierunki file
        function buildKierunkiMap(lines) {
            const kierunkiMap = new Map();
            lines.forEach((line) => {
                const parts = line.split("\t");
                if (parts.length >= 2) {
                    const linia = parts[0].trim();
                    const numerLiniiMatch = parts[1].match(/\[([^\]]+)\]/);
                    if (numerLiniiMatch) {
                        const numerLinii = numerLiniiMatch[1];
                        kierunkiMap.set(linia, numerLinii);
                    }
                }
            });
            return kierunkiMap;
        }

        // Normalize time to a standard format (HH:MM)
        function normalizeTime(time) {
            const [hours, minutes] = time.split(':').map(Number);
            const normalizedHours = hours >= 24 ? hours - 24 : hours;
            return `${String(normalizedHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        // Function to calculate time duration between start and end times (in minutes)
        function calculateDuration(startTime, endTime) {
            const [startHours, startMinutes] = startTime.split(":").map(Number);
            const [endHours, endMinutes] = endTime.split(":").map(Number);

            let durationHours = endHours - startHours;
            let durationMinutes = endMinutes - startMinutes;

            if (durationMinutes < 0) {
                durationMinutes += 60;
                durationHours -= 1;
            }

            if (durationHours < 0) {
                durationHours += 24; // Handle crossing midnight
            }

            return durationHours * 60 + durationMinutes; // Return duration in minutes
        }

        // Function to remove numbers from a string
        function removeNumbers(str) {
            return str.replace(/[0-9]/g, '').trim();
        }

        // Function to check if current time is between start and end times, handling midnight crossing
        function isCurrentTimeBetween(startTime, endTime) {
            const currentTime = new Date();
            const currentHours = currentTime.getHours();
            const currentMinutes = currentTime.getMinutes();
            const currentFormattedTime = `${String(currentHours).padStart(2, '0')}:${String(currentMinutes).padStart(2, '0')}`;

            // Convert times to minutes from midnight for easier comparison
            const getMinutesFromMidnight = (time) => {
                const [hours, minutes] = time.split(':').map(Number);
                return hours * 60 + minutes;
            };

            const startMinutes = getMinutesFromMidnight(startTime);
            const endMinutes = getMinutesFromMidnight(endTime);
            const currentMinutesFromMidnight = getMinutesFromMidnight(currentFormattedTime);

            // Case when end time is after start time
            if (startMinutes < endMinutes) {
                return currentMinutesFromMidnight >= startMinutes && currentMinutesFromMidnight <= endMinutes;
            } else {
                // Case when end time is before midnight (crossing midnight)
                return (
                    currentMinutesFromMidnight >= startMinutes || currentMinutesFromMidnight <= endMinutes
                );
            }
        }

        // Function to check if currentTime is between startTime and endTime, handling midnight crossing
        function isTimeBetween(currentTime, startTime, endTime) {
            if (startTime < endTime) {
                return currentTime > startTime && currentTime < endTime;
            } else {
                return currentTime > startTime || currentTime < endTime;
            }
        }

        function highlightCurrentTimeCells() {
            const tableRows = document.querySelectorAll("#rozkładTable tbody tr");
            let anyHighlighted = false; // Flag to check if any row is highlighted

            tableRows.forEach(row => {
                const startCell = row.cells[4]; // Godz. Rozp.
                const endCell = row.cells[5]; // Godz. Zak.

                if (startCell && endCell) {
                    const startTime = normalizeTime(startCell.innerText);
                    const endTime = normalizeTime(endCell.innerText);
                    console.log(`Start time: ${startTime}, End time: ${endTime}`); // Logging

                    // If current time is between start and end time, highlight the row
                    if (isCurrentTimeBetween(startTime, endTime)) {
                        row.style.backgroundColor = "rgb(75, 75, 75)";
                        row.classList.add("HighlitghtedRow");

                        anyHighlighted = true; // If any row is highlighted, set the flag
                    } else {
                        row.style.backgroundColor = ""; // Reset the background if not in range
                    }
                }
            });

            // If no row is highlighted, add a new row
            if (!anyHighlighted) {
                insertNewRowBetweenNearestTimes();
            }
        }

        // Function to insert a new row between the nearest "Godz. Zak." and "Godz. Rozp."
        function insertNewRowBetweenNearestTimes() {
            const tableBody = document.querySelector("#rozkładTable tbody");
            const tableRows = Array.from(tableBody.rows); // Convert NodeList to array

            let closestStartTime = null;
            let closestEndTime = null;
            let insertIndex = -1;
            let brake = 0; // Time difference between times

            for (let i = 0; i < tableRows.length - 1; i++) {
                const currentRow = tableRows[i];
                const nextRow = tableRows[i + 1];

                // Ensure that both startCell and endCell exist in the current and next rows
                const startCell = currentRow.cells[4]; // Godz. Rozp.
                const endCell = currentRow.cells[5]; // Godz. Zak.
                const nextStartCell = nextRow.cells[4]; // Godz. Rozp. in the next row

                if (startCell && endCell && nextStartCell) { // Check if cells exist
                    const startTime = normalizeTime(startCell.innerText);
                    const endTime = normalizeTime(endCell.innerText);
                    const nextStartTime = normalizeTime(nextStartCell.innerText); // Next row's start time

                    if (closestStartTime === null || (isCloserToCurrentTime(startTime, closestStartTime) && isCloserToCurrentTime(endTime, closestEndTime))) {
                        closestStartTime = startTime;
                        closestEndTime = endTime;
                        insertIndex = i + 1; // Insert after the current row

                        // Calculate time difference (Brake) between start and end time
                        brake = calculateDuration(startTime, endTime);
                    }
                }
            }

            // Insert the new row only if insertIndex is set (i.e. valid insertion point)
            if (insertIndex !== -1) {
                const nextRow = tableRows[insertIndex]; // Row below which the new row will be inserted
                const nextStartCell = nextRow.cells[4]; // Godz. Rozp. in the next row
                const nextStartTime = normalizeTime(nextStartCell.innerText); // Next start time

                // New row's start time is the next row's start time
                const newStartTime = nextStartTime;
                const newEndTime = closestEndTime; // End time remains the same as the previous row

                // Calculate time difference (Brake) between newStartTime and closestEndTime
                const timeDifference = calculateDuration(closestEndTime, newStartTime);

                // Calculate remaining time (brakeleft)
                const currentTime = new Date();
                const currentTimeFormatted = normalizeTime(`${String(currentTime.getHours()).padStart(2, '0')}:${String(currentTime.getMinutes()).padStart(2, '0')}`);
                const remainingTime = calculateDuration(currentTimeFormatted, newStartTime);

                // Check if current time is between newEndTime and newStartTime and if brakeleft is valid
                if (isTimeBetween(currentTimeFormatted, newEndTime, newStartTime)) {
                    const brakeleft = remainingTime;
                    if (brakeleft < timeDifference) {
                        // brakeleft is the difference between brake and remaining time
                        const newRow = document.createElement("tr");
                        newRow.innerHTML = `
                    <td colspan="8" style="background-color: rgb(75, 75, 75); text-align: center; font-size: 15px; padding: 3px;" class="blinkbrake">
                        Trwa przerwa ${timeDifference} min., pozostało: <strong> ${brakeleft} min.</strong>
                    </td>
                `;
                        tableBody.insertBefore(newRow, tableBody.rows[insertIndex]);
                    }
                } else {
                    // If the condition is not met, stop further execution
                    return;
                }
            } else {
                // If insertIndex is -1, stop execution (no valid row to insert)
                return;
            }
        }


        // Function to compare which time is closer to the current time
        function isCloserToCurrentTime(time1, time2) {
            const currentTime = new Date();
            const currentFormatted = normalizeTime(`${String(currentTime.getHours()).padStart(2, '0')}:${String(currentTime.getMinutes()).padStart(2, '0')}`);

            const time1Diff = calculateDuration(currentFormatted, time1);
            const time2Diff = calculateDuration(currentFormatted, time2);

            return time1Diff < time2Diff;
        }




        // Helper function to calculate time difference in minutes, handling midnight crossing
        function calculateTimeDifference(startTime, endTime) {
            const [startHours, startMinutes] = startTime.split(":").map(Number);
            const [endHours, endMinutes] = endTime.split(":").map(Number);
            const startTotal = startHours * 60 + startMinutes;
            const endTotal = endHours * 60 + endMinutes;
            let diff = endTotal - startTotal;
            if (diff < 0) {
                diff += 24 * 60; // Add 24 hours if end time is before start time
            }
            return diff;
        }

        // Helper function to check which time is closer to the current time
        function isCloserToCurrentTime(time1, time2) {
            const currentTime = new Date();
            const currentMinutes = currentTime.getHours() * 60 + currentTime.getMinutes();

            const time1Minutes = time1.split(":").map(Number).reduce((acc, time) => acc * 60 + time);
            const time2Minutes = time2.split(":").map(Number).reduce((acc, time) => acc * 60 + time);

            const diff1 = Math.min(Math.abs(currentMinutes - time1Minutes), 1440 - Math.abs(currentMinutes - time1Minutes));
            const diff2 = Math.min(Math.abs(currentMinutes - time2Minutes), 1440 - Math.abs(currentMinutes - time2Minutes));

            return diff1 < diff2;
        }

        async function processGOTOWEData(lines) {
            let tableBody = document.querySelector("#rozkładTable tbody");
            let lp = 1;
            let currentRouteId = null;
            let firstStop = null;
            let lastStop = null;
            let startTime = null;
            let endTime = null;
            let tripId = null;

            lines.slice(2).forEach((line) => {
                line = line.trim();

                if (line === "") {
                    if (currentRouteId && firstStop && lastStop && startTime && endTime) {
                        // Obliczanie różnicy czasu w minutach
                        const durationInMinutes = calculateDuration(startTime, endTime);

                        // Przekształcenie minut na godziny i minuty
                        const hours = Math.floor(durationInMinutes / 60);
                        const minutes = durationInMinutes % 60;

                        // Formatowanie w formacie HH:MM
                        const durationFormatted = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

                        let row = document.createElement("tr");
                        row.innerHTML +=
                            `<td><a class="NrOflp" href="BrygadaSzczegoly.html" onclick="savetripid('${tripId}')" >${lp}.</a></td>
             <td class="NrOfLine">${currentRouteId}</td>
             <td>${firstStop}</td>
             <td>${lastStop}</td>
             <td>${startTime}</td>
             <td>${endTime}</td>
             <td>${durationFormatted}</td>
             <td style="display: none;">N/A</td>
             <td class="hide">${tripId}</td>
             <td class="hide">${currentRouteId}</td>`;



                        tableBody.appendChild(row);
                        lp++;
                        currentRouteId = null;
                        firstStop = null;
                        lastStop = null;
                        startTime = null;
                        endTime = null;
                        tripId = null;
                    }
                } else if (line.includes("Rezerwa")) {
                    // Jeżeli linia zawiera słowo "Rezerwa"
                    let parts = line.split("\t");

                    // Zakładamy, że części będą miały postać: "Rezerwa" i godziny w formacie "Godz_Rozp-Godz_Zak"
                    let godzRozp = parts[3];
                    let godzZak = parts[4];
                    let godzRozpConv = null;
                    let godzZakConv = null;
                    let rezerwatime = null;
                    godzRozpConv = normalizeTime(godzRozp);
                    godzZakConv = normalizeTime(godzZak);
                    const czasrezerwa = calculateTimeDifference(godzRozp, godzZak);
                    rezerwatime = convertTimeToMinutes(czasrezerwa);
                    let row = document.createElement("tr");
                    row.innerHTML +=
                        `
<td class="RezLP"></td>
<td class="Rez"></td>
<td class="Rez">Rezerwa</td>
<td class="Rez"></td>
<td>${godzRozpConv}</td>
<td>${godzZakConv}</td>
<td>${rezerwatime}</td>
<td style="display: none;">N/A</td>`;

                    tableBody.appendChild(row);

                } else {
                    let parts = line.split(/\s+/);
                    let routeId = parts[0]; // Assuming this is the identifier you want
                    let arrivalTime = parts[3];
                    let stopName = parts.slice(5).join(" ");
                    tripId = parts[2]; // Przypisz trip_id

                    if (!currentRouteId) {
                        currentRouteId = routeId;
                        firstStop = stopName;
                        startTime = normalizeTime(arrivalTime);
                    }
                    lastStop = stopName;
                    endTime = normalizeTime(arrivalTime);
                }
            });

            // Dodaj ostatni wiersz, jeśli istnieje
            if (currentRouteId && firstStop && lastStop && startTime && endTime) {
                const duration = calculateDuration(startTime, endTime);
                let row = document.createElement("tr");
                row.innerHTML +=
                    `<td><a class="NrOflp" href="Szczegoly.html">${lp}.</a></td>
             <td>${currentRouteId}</td>
             <td>${firstStop}</td>
             <td>${lastStop}</td>
             <td>${startTime}</td>
             <td>${endTime}</td>
             <td>${duration}</td>
             <td style="display: none;">N/A</td>
             <td class="hide">${tripId}</td>`;
                tableBody.appendChild(row);
                lp++;
            }

            // Fetch kierunki and update the lines
            const kierunkiLines = await fetchKierunkiFile();
            if (kierunkiLines) {
                const kierunkiMap = buildKierunkiMap(kierunkiLines);
                for (let row of tableBody.rows) {
                    const liniaCell = row.cells[1];
                    const liniaValue = liniaCell ? liniaCell.innerText : null;
                    if (liniaValue && kierunkiMap.has(liniaValue)) {
                        liniaCell.innerText = kierunkiMap.get(liniaValue);
                    }
                }
            } else {
                console.error("Nie udało się wczytać Kierunki.txt.");
            }
        }

        // Pobranie pełnej ścieżki do pliku
        const fullPath = window.location.pathname;

        // Podzielenie ścieżki na części na podstawie "/"
        const pathParts = fullPath.split('/');

        // Pobranie nazwy folderu (zakładamy, że folder jest bezpośrednio nad plikiem)
        const folderName = pathParts[pathParts.length - 2]; // -2, bo ostatni element to nazwa pliku

        // Inicjalizacja zmiennej brygadaNumber na podstawie folderu
        let brygadaNumber;

        switch (folderName) {
            case 'Niedzielny':
                brygadaNumber = 'Niedzielny';
                break;
            case 'Powszedni':
                brygadaNumber = 'Powszedni';
                break;
            case 'Powszedni_Wolny':
                brygadaNumber = 'Powszedni_Wolny';
                break;
            case 'Sobotni':
                brygadaNumber = 'Sobotni';
                break;
            default:
                brygadaNumber = '2'; // Domyślna wartość, jeśli folder nie pasuje do żadnego przypadku
        }

        // Zmienna, która przechowuje stan wyróżnienia
        let isHighlighted = false;
        // Funkcja do wyróżniania unikalnych wartości w kolumnie "Linia"
        function toggleHighlight() {
            const tableRows = document.querySelectorAll("#rozkładTable tbody tr");
            const uniqueLines = new Set();
            const lineColors = {};
            const colors = ["#CD853F", "#778899", "#4169E1", "#20B2AA", "#6A5ACD", "#228B22"];
            let colorIndex = 0;

            // Jeśli jest włączone wyróżnienie, resetujemy kolory i przerywamy funkcję
            if (isHighlighted) {
                tableRows.forEach(row => {
                    const lineCell = row.querySelector(".NrOfLine");
                    if (lineCell) {
                        // Przywracamy oryginalny tekst, który zapisaliśmy w atrybucie data-original-text
                        const originalText = lineCell.getAttribute("data-original-text");
                        if (originalText) {
                            lineCell.innerText = originalText;
                        }
                    }
                });
                isHighlighted = false;
                document.getElementById("highlightButton").innerText = "Wyróżnij linie"; // Zmień tekst przycisku
                return;
            }

            // Iterujemy przez wiersze, aby zidentyfikować unikalne wartości w kolumnie "Linia"
            tableRows.forEach(row => {
                const lineCell = row.querySelector(".NrOfLine");
                if (lineCell) {
                    const lineValue = lineCell.innerText;
                    uniqueLines.add(lineValue);
                }
            });

            // Przypisujemy unikalny kolor do każdej unikalnej wartości w kolumnie "Linia"
            uniqueLines.forEach(line => {
                lineColors[line] = colors[colorIndex % colors.length];
                colorIndex++;
            });

            // Ustawiamy kolor tylko dla tekstu w komórce w kolumnie "Linia", na podstawie wartości
            tableRows.forEach(row => {
                const lineCell = row.querySelector(".NrOfLine");
                if (lineCell && lineColors[lineCell.innerText]) {
                    const lineValue = lineCell.innerText;

                    // Zapisz oryginalny tekst komórki, aby można było go później przywrócić
                    if (!lineCell.getAttribute("data-original-text")) {
                        lineCell.setAttribute("data-original-text", lineValue);
                    }

                    // Dodaj `span` z odpowiednim stylem wokół tekstu
                    lineCell.innerHTML = `<span class="highlighted-text" style="
                background-color: ${lineColors[lineValue]};
                color: white;
                border-radius: 5px;
                padding: 2px 5px;
                display: inline-block;
                font-weight: bold;
            ">${lineValue}</span>`;
                }
            });

            isHighlighted = true;
            document.getElementById("highlightButton").innerText = "Nie wyróżniaj linii"; // Zmień tekst przycisku
        }

        // Dodanie nasłuchu kliknięcia na przycisk "Wyróżnij linie"
        document.getElementById("highlightButton").addEventListener("click", toggleHighlight);
        window.onload = init;

        function savetripid(clickedTripId) {
            // Zapisz kliknięty tripid
            sessionStorage.setItem('savedtripid', clickedTripId);

            // Zbierz wszystkie tripid z tabeli
            const allTripIds = Array.from(document.querySelectorAll("#rozkładTable tbody tr"))
                .map(row => {
                    const cells = row.querySelectorAll("td");
                    return cells.length >= 9 ? cells[8].textContent.trim() : null;
                })
                .filter(id => id); // usuń puste/null

            // Zapisz je jako jeden string rozdzielony przecinkami
            sessionStorage.setItem('alltripids', allTripIds.join(","));
        }


        // Funkcja globalna: Dodawanie wiersza na podstawie warunku
        function checkAndAddRow() {
            const brygadaType = sessionStorage.getItem("BrygadaType");
            const tabelaWykaz = document.querySelector("#wykazbrygady #dane-wykaz");
            const tabelaRozklad = document.querySelector("#rozkładTable #dane-tabeli");

            if (!tabelaWykaz || !tabelaRozklad) {
                console.error("Nie znaleziono jednej z wymaganych tabel.");
                addErrorRow(tabelaWykaz);
                return;
            }

            logTableContent(tabelaRozklad);

            const godzRozp = findFirstAvailableStartTime(tabelaRozklad);
            const godzZak = findLatestEndTime(tabelaRozklad);

            if (!godzRozp || !godzZak) {
                console.error("Nie znaleziono wartości w kolumnach 'Godz. Rozp.' lub 'Godz. Zak.' w tabeli rozkładTable.");
                addErrorRow(tabelaWykaz);
                return;
            }

            if (brygadaType === "Brygada Jednozmianowa" || brygadaType === "Brygada Nocna Jednozmianowa") {
                const roznica = calculateTimeDifference(godzRozp, godzZak);
                tabelaWykaz.appendChild(createRow("A", godzRozp, godzZak, roznica));
            } else if (brygadaType === "Brygada Dwuzmianowa") {
                const savedpodmiana = sessionStorage.getItem('godzina');
                if (savedpodmiana) {
                    const roznicaA = calculateTimeDifference(godzRozp, savedpodmiana);
                    const roznicaB = calculateTimeDifference(savedpodmiana, godzZak);

                    tabelaWykaz.appendChild(createRow("A", godzRozp, savedpodmiana, roznicaA));
                    tabelaWykaz.appendChild(createRow("B", savedpodmiana, godzZak, roznicaB));
                } else {
                    const ZakonczenieA = sessionStorage.getItem('godzinaZakonczenieA');
                    const RozpoczecieB = sessionStorage.getItem('godzinaRozpoczeciaB');

                    if (!ZakonczenieA || !RozpoczecieB) {
                        console.error("Brak wartości dla ZakonczenieA lub RozpoczecieB w sessionStorage.");
                        addErrorRow(tabelaWykaz);
                        return;
                    }

                    const roznicaA = calculateTimeDifference(godzRozp, ZakonczenieA);
                    const roznicaB = calculateTimeDifference(RozpoczecieB, godzZak);

                    tabelaWykaz.appendChild(createRow("A", godzRozp, ZakonczenieA, roznicaA));
                    tabelaWykaz.appendChild(createRow("B", RozpoczecieB, godzZak, roznicaB));
                }
            } else if (brygadaType === "Brygada Szczytowa") {
                const ZakPrzedPrzerwa = sessionStorage.getItem("NajdluzszaPrzerwa_GodzZak");
                const RozpPoPrzerwa = sessionStorage.getItem("godz_rozp_przerwa");

                if (!godzRozp || !godzZak || !ZakPrzedPrzerwa || !RozpPoPrzerwa) {
                    console.error("Brak wartości w sessionStorage dla jednej z wymaganych zmiennych.");
                    addErrorRow(tabelaWykaz);
                    return;
                }
                const roznicaA = calculateTimeDifference(godzRozp, ZakPrzedPrzerwa);
                const roznicaB = calculateTimeDifference(RozpPoPrzerwa, godzZak);

                tabelaWykaz.appendChild(createRow("A", godzRozp, ZakPrzedPrzerwa, roznicaA));
                tabelaWykaz.appendChild(createRow("B", RozpPoPrzerwa, godzZak, roznicaB));
            } else {
                // Jeżeli brygadaType jest nieznany, też dodajemy wiersz błędu
                console.error("Nieznany typ brygady:", brygadaType);
                addErrorRow(tabelaWykaz);
            }
        }

        function addErrorRow(tabelaWykaz) {
            if (!tabelaWykaz) return; // Jeśli tabela nie istnieje, nie robimy nic

            const row = document.createElement("tr");
            const cell = document.createElement("td");
            cell.colSpan = 5; // scalamy wszystkie kolumny
            cell.style.textAlign = "center";
            cell.textContent = "Brak danych";
            row.appendChild(cell);

            tabelaWykaz.appendChild(row);
        }


        function createRow(label, godzRozp, godzZak, roznica) {
            const row = document.createElement("tr");
            row.innerHTML = `
        <td>${label}</td>
        <td>${godzRozp}</td>
        <td>${godzZak}</td>
        <td>${roznica}</td>
        <td style="display: none;">N/A</td>
    `;
            return row;
        }




        // Funkcja globalna: Znajdowanie pierwszej dostępnej wartości w kolumnie "Godz. Rozp."
        function findFirstAvailableStartTime(tabelaRozklad) {
            const rows = tabelaRozklad.querySelectorAll("tr");
            for (const row of rows) {
                const godzRozpCell = row.cells[4]; // Kolumna "Godz. Rozp." (indeks 4)
                if (godzRozpCell && godzRozpCell.textContent.trim()) {
                    return godzRozpCell.textContent.trim();
                }
            }
            return null;
        }



        function findLatestEndTime(tabelaRozklad) {
            const rows = Array.from(tabelaRozklad.querySelectorAll("tr")); // Pobieramy wszystkie wiersze tabeli jako tablicę

            // Iterujemy od ostatniego wiersza do pierwszego
            for (let i = rows.length - 1; i >= 0; i--) {
                const godzZakCell = rows[i].cells[5]; // Kolumna "Godz. Zak." (indeks 5)

                // Sprawdzamy, czy komórka zawiera niepustą wartość
                if (godzZakCell && godzZakCell.textContent.trim()) {
                    return godzZakCell.textContent.trim(); // Zwracamy pierwszą znalezioną niepustą wartość
                }
            }

            // Jeśli nie znaleziono żadnej wartości, zwracamy null
            return null;
        }

        // Funkcja globalna: Konwersja czasu w formacie HH:MM na minuty od początku dnia
        function convertTimeToMinutes(time) {
            try {
                const [hours, minutes] = time.split(":").map(Number);
                if (isNaN(hours) || isNaN(minutes)) {
                    throw new Error("Niepoprawny format czasu.");
                }
                return (hours % 24) * 60 + minutes; // Modulo obsługuje godziny po północy
            } catch (error) {
                console.error("Błąd konwersji czasu:", error);
                return null; // Możesz zwrócić null lub jakąś domyślną wartość
            }
        }




        // Funkcja globalna: Logowanie zawartości tabeli (dla diagnostyki)
        function logTableContent(tabelaRozklad) {
            const rows = tabelaRozklad.querySelectorAll("tr");
            rows.forEach((row, index) => {
                const godzRozpCell = row.cells[4]; // Kolumna "Godz. Rozp." (indeks 4)
                const godzZakCell = row.cells[5]; // Kolumna "Godz. Zak." (indeks 5)
                console.log(`Wiersz ${index + 1}: Rozp: ${godzRozpCell ? godzRozpCell.textContent.trim() : "Brak"} | Zak: ${godzZakCell ? godzZakCell.textContent.trim() : "Brak"}`);
            });
        }

        // Funkcja globalna: Obliczanie różnicy czasu, z obsługą godzin po północy
        function calculateTimeDifference(start, end) {
            const startMinutes = convertTimeToMinutes(start);
            const endMinutes = convertTimeToMinutes(end);

            let diffMinutes;
            if (endMinutes < startMinutes) {
                // Obsługa przejścia przez północ (dodajemy 24 godziny)
                diffMinutes = (endMinutes + 24 * 60) - startMinutes;
            } else {
                diffMinutes = endMinutes - startMinutes;
            }

            const hours = Math.floor(diffMinutes / 60);
            const minutes = diffMinutes % 60;

            // Formatowanie godzin i minut do 2 cyfr
            const formattedHours = String(hours).padStart(2, '0');
            const formattedMinutes = String(minutes).padStart(2, '0');

            return `${formattedHours}:${formattedMinutes}`;
        }









        async function addPodmianaRows() {
            try {
                const pathParts = window.location.pathname.split("/");
                const folderName = pathParts[pathParts.length - 2];
                console.log("Nazwa folderu:", folderName);

                let brygadaNumber;
                switch (folderName) {
                    case 'Niedzielny':
                        brygadaNumber = 'Niedzielny';
                        break;
                    case 'Powszedni':
                        brygadaNumber = 'Powszedni';
                        break;
                    case 'PowszedniWolny':
                        brygadaNumber = 'Powszedni_Wolny';
                        break;
                    case 'Sobotni':
                        brygadaNumber = 'Sobotni';
                        break;
                    default:
                        brygadaNumber = '2';
                }

                const brygadaTitle = sessionStorage.getItem("brygadaTitle");
                if (!brygadaTitle) {
                    console.error("Nie znaleziono brygadaTitle w sessionStorage.");
                    return;
                }

                const basePath = `../../../Brygady/${Miasto}/WYNIKI/Gotowe_brygady/${ChoosedTypeOfRozklad}/${brygadaTitle}`;
                const podmianaPath = `${basePath}/podmiana.txt`;
                console.log("Ścieżka do pliku:", podmianaPath);

                // Sprawdzenie istnienia pliku podmiana.txt
                const response = await fetch(podmianaPath);
                if (response.ok) {
                    const text = await response.text();
                    processPodmianaFile(text);
                } else {
                    console.warn("Plik podmiana.txt nie istnieje. Sprawdzanie alternatywnych plików...");
                    const zakonczenieAPath = `${basePath}/ZakonczenieA.txt`;
                    const rozpoczecieBPath = `${basePath}/RozpoczecieB.txt`;

                    const [zakonczenieAResponse, rozpoczecieBResponse] = await Promise.all([
                        fetch(zakonczenieAPath),
                        fetch(rozpoczecieBPath)
                    ]);

                    if (zakonczenieAResponse.ok && rozpoczecieBResponse.ok) {
                        const zakonczenieAContent = await zakonczenieAResponse.text();
                        const rozpoczecieBContent = await rozpoczecieBResponse.text();

                        const [przystanekZakonczenieA, godzinaZakonczenieA] = parseFileContent(zakonczenieAContent);
                        const [przystanekRozpoczecieB, godzinaRozpoczeciaB] = parseFileContent(rozpoczecieBContent);

                        insertRowAtCorrectPosition(
                            przystanekZakonczenieA,
                            godzinaZakonczenieA,
                            przystanekRozpoczecieB,
                            godzinaRozpoczeciaB
                        );
                    } else {
                        console.error("Nie znaleziono wymaganych plików ZakonczenieA.txt i RozpoczecieB.txt.");
                    }
                }
            } catch (error) {
                console.error("Wystąpił błąd:", error);
            }
        }

        function processPodmianaFile(text) {
            const podmianaLines = text.split("\n").map(line => line.trim()).filter(line => line);


            let tableBody = document.querySelector("#rozkładTable tbody");
            if (!tableBody) {
                console.error("Nie znaleziono tabeli z id 'rozkładTable'.");
                return;
            }

            let tableRows = Array.from(tableBody.querySelectorAll("tr"));
            const now = new Date();
            const currentTimeFormatted = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;

            podmianaLines.forEach((line) => {
                const [przystanek, godzina] = line.split("\t").map(item => item.trim());

                for (let i = 0; i < tableRows.length - 1; i++) {
                    const currentRow = tableRows[i];
                    const nextRow = tableRows[i + 1];
                    let currentTime = currentRow.cells[4]?.textContent;
                    let nextTime = nextRow.cells[4]?.textContent;
                    if (!nextTime) {
                        const thirdRow = tableRows[i + 2];
                        nextTime = thirdRow ? thirdRow.cells[4]?.textContent : null;
                    }
                    if (currentTime && nextTime && isBetween(godzina, currentTime, nextTime)) {
                        sessionStorage.setItem('godzina', godzina);
                        const displayedTime = (godzina === currentTimeFormatted) ? "TERAZ" : godzina;
                        const newRow = document.createElement("tr");
                        newRow.innerHTML = `<td colspan="9" style="text-align: center; font-size: 15px; padding: 3px;" class="podmiana">
            Podmiana: &nbsp; <strong>${przystanek}</strong> &nbsp;&nbsp; ${displayedTime}
            </td>`;

                        if (godzina === currentTimeFormatted) {
                            newRow.classList.add("blink");
                        }

                        tableBody.insertBefore(newRow, nextRow);
                        break;
                    }
                }
            });
        }


        function insertRowAtCorrectPosition(przystanekZakonczenieA, godzinaZakonczenieA, przystanekRozpoczecieB, godzinaRozpoczeciaB) {
            let tableBody = document.querySelector("#rozkładTable tbody");
            if (!tableBody) {
                console.error("Nie znaleziono tabeli z id 'rozkładTable'.");
                return;
            }

            let tableRows = Array.from(tableBody.querySelectorAll("tr"));
            for (let i = 0; i < tableRows.length - 1; i++) {
                const currentRow = tableRows[i];
                const nextRow = tableRows[i + 1];
                let currentTime = currentRow.cells[4]?.textContent;
                let nextTime = nextRow.cells[4]?.textContent;

                if (!nextTime && tableRows[i + 2]) {
                    nextTime = tableRows[i + 2].cells[4]?.textContent;
                }

                if (currentTime && nextTime && isBetween(godzinaZakonczenieA, currentTime, nextTime)) {

                    // ❗ Warunek: dodaj "Zjazd do zajezdni" tylko jeśli currentRow.kierunek != "Lubelska Zajezdnia MPK"
                    const currentRowKierunek = currentRow.cells[3]?.textContent?.trim();
                    const shouldAddZjazd = currentRowKierunek !== "Lubelska Zajezdnia MPK";
                    if (shouldAddZjazd) {
                        const extraRow = document.createElement("tr");
                        extraRow.innerHTML =
                            `<td colspan="9" id="PodmianaWIERSZ" style="background-color: rgb(163, 120, 0);">
            Zjazd Do Zajezdni 
        </td>`;
                        tableBody.insertBefore(extraRow, nextRow);
                    }

                    // Wiersz podmiany - bez zmian
                    const newRow = document.createElement("tr");
                    newRow.innerHTML =
                        `<td colspan="9" style="text-align: center; font-size: 15px; padding: 3px;" id="PodmianaBAZA">
            <strong> Podmiana: ${przystanekZakonczenieA} </strong><br>
            Zakończenie A: <strong> ${godzinaZakonczenieA} </strong> | Rozpoczęcie B: <strong> ${godzinaRozpoczeciaB} </strong>
        </td>`;
                    tableBody.insertBefore(newRow, nextRow);

                    sessionStorage.setItem("godzinaZakonczenieA", godzinaZakonczenieA);
                    sessionStorage.setItem("godzinaRozpoczeciaB", godzinaRozpoczeciaB);

                    // ❗ Warunek: dodaj "Wyjazd na linię" tylko jeśli nextRow.początek != "Lubelska Zajezdnia MPK"
                    const nextRowPoczatek = nextRow.cells[2]?.textContent?.trim();
                    const shouldAddWyjazd = nextRowPoczatek !== "Lubelska Zajezdnia MPK";
                    if (shouldAddWyjazd) {
                        const extraRow2 = document.createElement("tr");
                        extraRow2.innerHTML =
                            `<td colspan="9" id="PodmianaWIERSZ_DODATKOWY" style="background-color: rgb(163, 120, 0);">
            Wyjazd na linię 
        </td>`;
                        tableBody.insertBefore(extraRow2, nextRow);
                    }

                    break;
                }
            }
        }





        function parseFileContent(content) {
            const lines = content.split("\n").map(line => line.trim()).filter(line => line);
            if (lines.length > 0) {
                return lines[0].split("\t").map(item => item.trim());
            }
            return [null, null];
        }

        function isBetween(value, start, end) {
            const [valueH, valueM] = value.split(":").map(Number);
            const [startH, startM] = start.split(":").map(Number);
            const [endH, endM] = end.split(":").map(Number);

            const valueMinutes = valueH * 60 + valueM;
            const startMinutes = startH * 60 + startM;
            const endMinutes = endH * 60 + endM;

            return valueMinutes > startMinutes && valueMinutes < endMinutes;
        }







        function brygadabisowa() {
            const tableBody = document.getElementById("dane-tabeli");
            const rows = tableBody.getElementsByTagName("tr");
            let maxGap = 0;
            let maxGapIndex = -1;
            const brygadaType = sessionStorage.getItem("BrygadaType");

            if (brygadaType === "Brygada Szczytowa") {
                document.querySelectorAll("a.PrzerwaBisowa").forEach(el => el.style.display = "");




                // Funkcja pomocnicza do parsowania czasu (np. "14:30")
                function parseTime(timeString) {
                    if (!timeString) return null; // Jeśli null lub pusty, zwróć null
                    const [hours, minutes] = timeString.split(":").map(Number);
                    return hours * 60 + minutes; // Zwraca czas w minutach 
                }

                // Iteracja przez wiersze tabeli
                for (let i = 0; i < rows.length - 1; i++) {
                    const currentRow = rows[i];
                    const nextRow = rows[i + 1];

                    if (!currentRow || !nextRow) continue; // Upewniamy się, że oba wiersze istnieją

                    const endTimeCurrent = currentRow.cells[5]?.textContent.trim(); // "Godz. Zak."
                    let startTimeNext = nextRow.cells[4]?.textContent.trim(); // "Godz. Rozp."

                    // Jeśli "Godz. Rozp." wiersza następnego jest null, weź wartość z kolejnego wiersza (o ile istnieje)
                    if (!startTimeNext && rows[i + 2]) {
                        const nextNextRow = rows[i + 2];
                        startTimeNext = nextNextRow?.cells[4]?.textContent.trim();
                    }

                    // Parsowanie czasów
                    const endMinutes = parseTime(endTimeCurrent);
                    const startMinutes = parseTime(startTimeNext);

                    // Jeśli brak jednego z czasów, pomijamy tę parę
                    if (endMinutes === null || startMinutes === null) continue;

                    const gap = startMinutes - endMinutes;
                    if (gap > maxGap) {
                        maxGap = gap;
                        maxGapIndex = i;

                        sessionStorage.setItem("NajdluzszaPrzerwa_GodzZak", endTimeCurrent);
                        sessionStorage.setItem("NajdluzszaPrzerwa_GodzRozp", startTimeNext); // Zapisz godz. rozpoczęcia

                        console.log(endTimeCurrent);
                    }
                }

                // Dodanie nowego wiersza z informacją o najdłuższej przerwie
                if (maxGapIndex !== -1) {
                    const newRow = document.createElement("tr");

                    newRow.innerHTML =
                        `<td colspan="9" class="PrzerwaBisowa" style="text-align: center; background-color: purple;"> <strong> Przerwa bisowa </strong> <br> (${Math.floor(maxGap / 60)}h ${maxGap % 60}min) </td>`;
                    // Wstaw nowy wiersz po wierszu, który ma największą różnicę
                    tableBody.insertBefore(newRow, rows[maxGapIndex + 1]);

                    // Zapisz godzinę rozpoczęcia w sessionStorage po dodaniu wiersza
                    const godzRozp = sessionStorage.getItem("NajdluzszaPrzerwa_GodzRozp");
                    sessionStorage.setItem("godz_rozp_przerwa", godzRozp); // Zapisz godzinę rozpoczęcia po dodaniu wiersza

                }
            }
        }


        function WyjazdNaLinie() {
            const tableBody = document.querySelector("#rozkładTable tbody");
            // Add the "Wyjazd Na Linie" row if needed
            let wyjazdAdded = false;
            if (tableBody.rows.length > 0) {
                const firstPoczątekValue = tableBody.rows[0].cells[2].innerText.trim();
                const wasRezerwa = firstPoczątekValue === "Rezerwa";
                const nextRowPoczątekValue = tableBody.rows[1].cells[2].innerText.trim();

                // Jeśli pierwsza komórka nie jest "Lubelska Zajezdnia MPK"
                if (firstPoczątekValue !== "Lubelska Zajezdnia MPK") {
                    // Jeżeli wartość w pierwszej komórce nie jest "Rezerwa" i druga komórka nie zawiera "Lubelska Zajezdnia MPK"
                    if (!wasRezerwa || nextRowPoczątekValue !== "Lubelska Zajezdnia MPK") {
                        let wyjazdRow = document.createElement("tr");
                        let wyjazdCell = document.createElement("td");
                        wyjazdCell.colSpan = 9;
                        wyjazdCell.innerText = "Wyjazd Na Linie";
                        wyjazdCell.classList.add("WNL");
                        wyjazdCell.style.textAlign = "center"; // Wyśrodkowanie tekstu
                        wyjazdRow.appendChild(wyjazdCell);
                        tableBody.insertBefore(wyjazdRow, tableBody.rows[0]);
                        wyjazdRow.style.backgroundColor = "rgba(163, 120, 0)";
                        wyjazdAdded = true;
                    }
                }
            }
        }

        function PrzejazdTechniczny() {
            const tableBody = document.querySelector("#rozkładTable tbody");
            // Przejazd Techniczny
            const exceptions = ["Głogów Młp. Leniar I  nż", "Głogów Młp. Leniar I  nż", "Langiewicza / Wita Stwosza", "Wita Stwosza pętla", "Ustrzycka  nż", "Ustrzycka / Magórska ", "Ogrodowa bloki", "Kwiatkowskiego urząd miasta"];
            let rowCount = tableBody.rows.length; // Zapisz początkową liczbę wierszy w tabeli

            for (let i = 0; i < rowCount - 1; i++) {
                // Sprawdź, czy to już ostatni wiersz
                if (i === rowCount - 2) {
                    break; // Przerywamy działanie pętli, jeśli osiągnęliśmy przedostatni wiersz
                }

                const currentRow = tableBody.rows[i];
                const nextRow = tableBody.rows[i + 1];
                const kierunekValue = currentRow.cells[3] ? currentRow.cells[3].innerText : null;
                let początekValue = nextRow.cells[2] ? nextRow.cells[2].innerText : null;
                let cleanKierunek = kierunekValue ? removeNumbers(kierunekValue).trim() : null;
                let cleanPoczątek = początekValue ? removeNumbers(początekValue).trim() : null;

                // Sprawdzamy, czy cleanPoczątek to "Rezerwa"
                const wasRezerwa = cleanPoczątek === "Rezerwa";

                // Jeśli cleanPoczątek to "Rezerwa", to zaktualizuj go o wartość z kolejnego wiersza (i + 2)
                if (wasRezerwa && tableBody.rows[i + 2]) {
                    const nextNextRow = tableBody.rows[i + 2];
                    początekValue = nextNextRow.cells[2] ? nextNextRow.cells[2].innerText : null;
                    cleanPoczątek = początekValue ? removeNumbers(początekValue).trim() : null;
                }

                // Sprawdzamy, czy cleanKierunek jest różne od cleanPoczątek po aktualizacji
                if (cleanKierunek && cleanPoczątek && cleanKierunek !== cleanPoczątek) {
                    let isNotException = true;

                    // Sprawdzenie wyjątków
                    for (let exception of exceptions) {
                        if (cleanKierunek === exception || cleanPoczątek === exception) {
                            isNotException = false;
                            break;
                        }
                    }

                    // Jeśli nie ma wyjątków, dodaj wiersz "Przejazd Techniczny"
                    if (isNotException) {
                        let przejazdRow = document.createElement("tr");
                        let przejazdCell = document.createElement("td");
                        przejazdCell.colSpan = 9;
                        przejazdCell.innerText = "Przejazd Techniczny";
                        przejazdCell.style.textAlign = "center";
                        przejazdCell.classList.add("PT");
                        przejazdRow.appendChild(przejazdCell);

                        // Dodaj "Przejazd Techniczny" poniżej tylko w przypadku, gdy początkowy cleanPoczątek wynosił "Rezerwa"
                        if (wasRezerwa) {
                            tableBody.insertBefore(przejazdRow, nextRow.nextSibling); // Dodaj po currentRow
                            rowCount++; // Zwiększamy rowCount, bo dodaliśmy wiersz
                            i++; // Zwiększ i, aby pominąć dodany wiersz
                        } else {
                            tableBody.insertBefore(przejazdRow, nextRow);
                            rowCount++; // Zwiększamy rowCount, bo dodaliśmy wiersz
                            i++; // Zwiększ i, aby pominąć dodany wiersz
                        }

                        przejazdRow.style.backgroundColor = "rgba(163, 120, 0)";
                    }
                }
            }
        }

        function ZjazdDoZajezdni() {
            // Add the "Zjazd Do Zajezdni" row if needed
            const tableBody = document.querySelector("#rozkładTable tbody");
            if (tableBody.rows.length > 0) {
                const lastRow = tableBody.rows[tableBody.rows.length - 1];
                const beflastRow = tableBody.rows[tableBody.rows.length - 2];
                const KierunekValue = beflastRow.cells[3].innerText.trim();

                // Check if the last row has enough cells (at least 4 cells)
                if (lastRow.cells.length > 3) {
                    const lastKierunekValue = lastRow.cells[3].innerText.trim();

                    const lastPoczatekValue = lastRow.cells[2].innerText.trim();

                    if (lastKierunekValue !== "Lubelska Zajezdnia MPK" && lastPoczatekValue !== "Rezerwa") {
                        let zjazdRow = document.createElement("tr");
                        let zjazdCell = document.createElement("td");
                        zjazdCell.colSpan = 9;
                        zjazdCell.innerText = "Zjazd Do Zajezdni";
                        zjazdCell.classList.add("ZDZ");
                        zjazdCell.style.textAlign = "center";
                        zjazdRow.appendChild(zjazdCell);
                        tableBody.appendChild(zjazdRow);
                        zjazdRow.style.backgroundColor = "rgba(163, 120, 0)";
                    } else if (lastPoczatekValue == "Rezerwa" && KierunekValue !== "Lubelska Zajezdnia MPK") {

                        let zjazdRow = document.createElement("tr");
                        let zjazdCell = document.createElement("td");
                        zjazdCell.colSpan = 9;
                        zjazdCell.innerText = "Zjazd Do Zajezdni";
                        zjazdCell.style.textAlign = "center";
                        zjazdRow.appendChild(zjazdCell);
                        tableBody.appendChild(zjazdRow);
                        zjazdRow.style.backgroundColor = "rgba(163, 120, 0)";

                    }
                }
            }
        }

        /*
                function usunzbedne() {
                    const zakazaneSlowa = ['pętla', 'nż', 'granica']; // Lista zakazanych słów
                    const table = document.getElementById('rozkładTable');
                    const rows = table.getElementsByTagName('tr');

                    for (let i = 1; i < rows.length; i++) { // zaczynamy od 1, ponieważ 0 to nagłówki
                        const cells = rows[i].getElementsByTagName('td');

                        for (let j = 0; j < cells.length; j++) {
                            const cell = cells[j];
                            const links = cell.getElementsByTagName('a');

                            // Sprawdzamy, czy w komórce są linki
                            if (links.length > 0) {
                                // Dla każdego linku nie usuwamy jego tekstu
                                for (let link of links) {
                                    let linkText = link.innerText;
                                    // Usuwamy zakazane słowa z tekstu linku
                                    for (let slowo of zakazaneSlowa) {
                                        linkText = linkText.replace(new RegExp(slowo, 'g'), '');
                                    }
                                    link.innerText = linkText;
                                }
                            } else {
                                // Jeśli w komórce nie ma linków, to usuwamy tekst normalnie
                                let cellText = cell.innerText;
                                // Usuwamy zakazane słowa
                                for (let slowo of zakazaneSlowa) {
                                    cellText = cellText.replace(new RegExp(slowo, 'g'), '');
                                }

                                // Usuwamy cyfry w 3. i 4. kolumnie
                                if (j === 2 || j === 3) { // Indeksy zaczynają się od 0, więc 2 to 3. kolumna, a 3 to 4. kolumna
                                    cellText = cellText.replace(/\d+/g, ''); // Usuwamy wszystkie cyfry
                                }

                                // Sprawdzamy, czy tekst zawiera "p."
                                const pIndex = cellText.indexOf("p.");
                                if (pIndex !== -1) {
                                    // Dzielimy tekst na dwie części: przed "p." i po "p."
                                    const beforeP = cellText.substring(0, pIndex); // Tekst przed "p."
                                    const afterP = cellText.substring(pIndex); // Tekst po "p." (włącznie)

                                    // Tworzymy nowe elementy HTML
                                    const newContent = document.createElement("div");
                                    newContent.innerHTML = beforeP + "<br><span style='color: grey;'>" + "(" + afterP + ")" + "</span>";

                                    // Zastępujemy tekst w komórce
                                    cell.innerHTML = newContent.innerHTML;
                                } else {
                                    // Jeśli nie ma "p.", ustawiamy zwykły tekst
                                    cell.innerText = cellText;
                                }
                            }
                        }
                    }
                }

        */


        function usunZakazaneSlowaICyfry() {
            const zakazaneSlowa = ['pętla', 'nż', 'granica', 'Skrzyż. Młyn', 'OSP', 'skrzyż. młyn']; // Lista zakazanych słów
            const table = document.getElementById('rozkładTable');
            const rows = table.getElementsByTagName('tr');

            for (let i = 1; i < rows.length; i++) { // zaczynamy od 1, ponieważ 0 to nagłówki
                const cells = rows[i].getElementsByTagName('td');

                for (let j = 0; j < cells.length; j++) {
                    const cell = cells[j];
                    const links = cell.getElementsByTagName('a');
                    let cellHTML = cell.innerHTML; // Zmiana z innerText na innerHTML

                    // Sprawdzamy, czy w komórce są linki
                    if (links.length > 0) {
                        // Jeśli są linki, pomijamy modyfikowanie tekstu komórki
                        for (let link of links) {
                            // Usuwamy zakazane słowa z tekstu linku, ale nie z całego HTML
                            let linkText = link.innerText;
                            for (let slowo of zakazaneSlowa) {
                                linkText = linkText.replace(new RegExp(slowo, 'g'), '');
                            }
                            link.innerText = linkText;
                        }
                    } else {
                        // Usuwamy zakazane słowa z całego HTML
                        for (let slowo of zakazaneSlowa) {
                            cellHTML = cellHTML.replace(new RegExp(slowo, 'g'), '');
                        }

                        // Usuwamy cyfry w 3. i 4. kolumnie
                        if (j === 2 || j === 3) { // Indeksy zaczynają się od 0, więc 2 to 3. kolumna, a 3 to 4. kolumna
                            cellHTML = cellHTML.replace(/\d+/g, ''); // Usuwamy wszystkie cyfry
                        }
                    }

                    // Zaktualizowanie HTML komórki
                    cell.innerHTML = cellHTML;
                }
            }
        }


        function sprawdzTekstPoP() {
            const table = document.getElementById('rozkładTable');
            const rows = table.getElementsByTagName('tr');

            for (let i = 1; i < rows.length; i++) { // zaczynamy od 1, ponieważ 0 to nagłówki
                const cells = rows[i].getElementsByTagName('td');

                for (let j = 0; j < cells.length; j++) {
                    const cell = cells[j];
                    let cellHTML = cell.innerHTML; // Używamy innerHTML, aby zachować strukturę HTML

                    // Sprawdzamy, czy tekst zawiera "p."
                    const pIndex = cellHTML.indexOf("p.");
                    if (pIndex !== -1) {
                        // Dzielimy tekst na dwie części: przed "p." i po "p."
                        const beforeP = cellHTML.substring(0, pIndex); // Tekst przed "p."
                        const afterP = cellHTML.substring(pIndex); // Tekst po "p." (włącznie)

                        // Lista wyjątków
                        const wyjatki = ["p. Leniar I", "p. Zelmer II"];

                        // Sprawdzamy, czy tekst po "p." jest jednym z wyjątków
                        let isException = false;
                        for (let wyjatek of wyjatki) {
                            if (afterP.includes(wyjatek)) {
                                isException = true;
                                break;
                            }
                        }

                        if (!isException) {
                            // Jeśli tekst po "p." nie jest wyjątkiem, dodajemy formatowanie
                            const newContent = document.createElement("div");
                            newContent.innerHTML = beforeP + "<br><span style='color: grey;'>" + "(" + afterP + ")" + "</span>";

                            // Zastępujemy tekst w komórce
                            cell.innerHTML = newContent.innerHTML;
                        }
                    } else {
                        // Jeśli nie ma "p.", ustawiamy zwykły tekst
                        cell.innerHTML = cellHTML;
                    }
                }
            }
        }

        async function updateKierunki() {
            let tableRows = document.querySelectorAll("#rozkładTable tbody tr"); // Pobieramy wszystkie wiersze tabeli
            for (let row of tableRows) {
                let routeCell = row.querySelector(".NrOfLine"); // Kolumna "Linia"
                let kierunekCell = row.querySelector("td:nth-child(4)"); // Kolumna "Kierunek"
                let tripId = row.querySelector("td:nth-child(9)").textContent; // Pobieramy tripId z ukrytej kolumny

                if (routeCell && routeCell.textContent === "1" && tripId) {
                    // Jeśli linia = 1 i tripId jest dostępne, szukamy w pliku Kierunki.txt
                    let kierunek = await findKierunek(tripId);
                    if (kierunek) {
                        kierunekCell.textContent = kierunek; // Uzupełniamy komórkę "Kierunek"
                    }
                }
            }
        }

        // Funkcja do wyszukiwania kierunku w pliku Kierunki.txt
        async function findKierunek(tripId) {
            try {
                let response = await fetch('../../../Kierunki.txt'); // Wczytujemy plik Kierunki.txt
                let text = await response.text();
                let lines = text.split("\n");

                // Przeszukujemy każdą linię pliku
                for (let line of lines) {
                    let parts = line.split("\t");
                    if (parts[0] === tripId) {
                        // Znaleźliśmy pasujący tripId, zwracamy kierunek (część po pauzie)
                        let kierunek = parts[2].split(" - ")[1];
                        return kierunek;
                    }
                }

                // Jeśli nie znaleziono pasującego tripId, zwróć null
                return null;
            } catch (error) {
                console.error("Błąd podczas ładowania pliku Kierunki.txt:", error);
                return null;
            }
        }




        async function scanTableForLine1() {
            // Pobierz wszystkie wiersze tabeli (poza nagłówkami)
            let rows = document.querySelectorAll("#rozkładTable tbody tr");

            // Lista dozwolonych linii
            const dozwoloneLinie = ["1", "4", "7", "8", "10", "15", "20", "28", "32", "51"];

            // Zmienna do przechowywania obietnic (Promises)
            const promises = [];

            // Iteruj po wierszach
            rows.forEach((row) => {
                if (row.cells.length < 2) return; // Pomijamy wiersze źle sformatowane

                let linia = row.cells[1].textContent.trim(); // Pobierz wartość z drugiej komórki (Linia)

                if (dozwoloneLinie.includes(linia)) {
                    let kodTrasy = row.cells[9].textContent.trim(); // Pobierz kod trasy z ostatniej komórki
                    console.log("Znaleziono kod trasy:", kodTrasy);

                    // Funkcja do pobrania i wyszukania kodu trasy w pliku
                    promises.push(fetchKierunki(kodTrasy, row)); // Dodaj obietnicę do tablicy
                }
            });

            // Czekaj na zakończenie wszystkich operacji fetchKierunki
            await Promise.all(promises);
        }

        async function fetchKierunki(kodTrasy, row) {
            try {
                const response = await fetch(`../../../Brygady/${Miasto}/WYNIKI/Kierunki.txt`);
                const data = await response.text();

                // Podziel zawartość pliku na linie
                const lines = data.split("\n");

                // Szukamy odpowiedniej linii z kodem trasy
                const foundLine = lines.find(line => line.split("\t")[0] === kodTrasy);

                if (foundLine) {
                    console.log("Znaleziono linię:", foundLine);

                    // Podziel linię po tabulatorach, aby uzyskać wartości
                    const parts = foundLine.split("\t");

                    // Załóżmy, że format jest taki, że $Koniec znajduje się po ostatnim "-"
                    const koniec = parts[parts.length - 1].split("-")[1]?.trim(); // Pobieramy wartość po "-"

                    if (koniec) {
                        // Zaktualizuj wartość w tabeli, w kolumnie "Kierunek" (indeks 3)
                        row.cells[3].textContent = koniec; // Kolumna Kierunek
                    } else {
                        console.log("Nie znaleziono wartości $Koniec w linii.");
                    }
                } else {
                    console.log("Nie znaleziono linii o kodzie trasy:", kodTrasy);
                }
            } catch (error) {
                console.error("Błąd podczas pobierania pliku Kierunki.txt:", error);
            }
        }



        function checkForBrake() {
            let button = document.getElementById('przerwaButton');
            let brakeRow = document.querySelector('#dane-tabeli .blinkbrake');

            if (brakeRow) {
                button.classList.add('BrakeDetected');
                button.classList.remove('NoBrakeDetected');

            } else {
                button.classList.add('NoBrakeDetected');
                button.classList.remove('BrakeDetected');
            }
        }


        document.getElementById("przerwaButton").addEventListener("click", function(event) {
            event.preventDefault();

            let rows = document.querySelectorAll("#dane-tabeli .blinkbrake");
            let isHidden = Array.from(rows).every(row => row.closest("tr").style.display === "none");

            rows.forEach(cell => {
                let row = cell.closest("tr");
                if (row) {
                    row.style.display = isHidden ? "table-row" : "none";
                }
            });

            this.textContent = isHidden ? "Ukryj przerwę" : "Pokaż przerwę";
        });




        function checkForPodmiana() {
            let button = document.getElementById('podmianaButton');
            let brakeRow = document.querySelector('#dane-tabeli .podmiana');

            if (brakeRow) {
                button.classList.add('PodmianaDetected');
                button.classList.remove('NoPodmianaDetected');

            } else {
                button.classList.add('NoPodmianaDetected');
                button.classList.remove('PodmianaDetected');
            }
        }


        document.getElementById("podmianaButton").addEventListener("click", function(event) {
            event.preventDefault();

            let rows = document.querySelectorAll("#dane-tabeli .podmiana");
            let isHidden = Array.from(rows).every(row => row.closest("tr").style.display === "none");

            rows.forEach(cell => {
                let row = cell.closest("tr");
                if (row) {
                    row.style.display = isHidden ? "table-row" : "none";
                }
            });

            this.textContent = isHidden ? "Ukryj podmianę" : "Pokaż podmianę";
        });




        function checkForHighlitghtedRow() {
            let button = document.getElementById('highlitghtedButton');
            let brakeRow = document.querySelector('#dane-tabeli .HighlitghtedRow');

            if (!brakeRow) {
                button.classList.add('NohighlightButton');
                button.classList.remove('highlightButton');
            } else {
                button.classList.add('highlightButton');
                button.classList.remove('NohighlightButton');
            }
        }

        document.getElementById("highlitghtedButton").addEventListener("click", function(event) {
            event.preventDefault();

            let rows = document.querySelectorAll("#dane-tabeli .HighlitghtedRow");
            let isActive = Array.from(rows).some(row => row.closest("tr").style.backgroundColor === "rgb(50, 50, 50)");

            rows.forEach(cell => {
                let row = cell.closest("tr");
                if (row) {
                    row.style.backgroundColor = isActive ? "rgb(75, 75, 75)" : "rgb(50, 50, 50)";
                }
            });

            this.textContent = isActive ? "Wyłącz podświetlenie" : "Włącz podświetlenie";
        });

        function checkForPT() {
            let button = document.getElementById('PTButton');
            let brakeRow = document.querySelector('#dane-tabeli .PT');

            if (brakeRow) {
                button.classList.add('PTDetected');
                button.classList.remove('NoPTDetected');

            } else {
                button.classList.add('NoPTDetected');
                button.classList.remove('PTDetected');
            }
        }


        document.getElementById("PTButton").addEventListener("click", function(event) {
            event.preventDefault();

            let rows = document.querySelectorAll("#dane-tabeli .PT");
            let isHidden = Array.from(rows).every(row => row.closest("tr").style.display === "none");

            rows.forEach(cell => {
                let row = cell.closest("tr");
                if (row) {
                    row.style.display = isHidden ? "table-row" : "none";
                }
            });

            this.textContent = isHidden ? "Ukryj PT" : "Pokaż PT";
        });


        function checkForWNLZDZ() {
            let button = document.getElementById('WNLZDZButton');
            let hasWNL = document.querySelector('#dane-tabeli .WNL') !== null;
            let hasZDZ = document.querySelector('#dane-tabeli .ZDZ') !== null;

            // Usuwamy wszystkie klasy, by uniknąć konfliktów
            button.classList.remove('WNLZDZDetected', 'NoWNLZDZDetected');

            // Warunki logiczne
            if (hasWNL || hasZDZ) {
                button.classList.add('WNLZDZDetected');
            } else {
                button.classList.add('NoWNLZDZDetected');
            }
        }

        document.getElementById("WNLZDZButton").addEventListener("click", function(event) {
            event.preventDefault();

            let rows = document.querySelectorAll("#dane-tabeli .WNL, #dane-tabeli .ZDZ");
            let isHidden = Array.from(rows).every(row => row.closest("tr").style.display === "none");

            rows.forEach(cell => {
                let row = cell.closest("tr");
                if (row) {
                    row.style.display = isHidden ? "table-row" : "none";
                }
            });

            this.textContent = isHidden ? "Ukryj WNL i ZDZ" : "Pokaż WNL i ZDZ";
        });


        function checkForPrzerwaBisowa() {
            let button = document.getElementById('PBButton');
            let brakeRow = document.querySelector('#dane-tabeli .PrzerwaBisowa');

            if (brakeRow) {
                button.classList.add('PBDetected');
                button.classList.remove('NoPBDetected');

            } else {
                button.classList.add('NoPBDetected');
                button.classList.remove('PBDetected');
            }
        }


        document.getElementById("PBButton").addEventListener("click", function(event) {
            event.preventDefault();

            let rows = document.querySelectorAll("#dane-tabeli .PrzerwaBisowa");
            let isHidden = Array.from(rows).every(row => row.closest("tr").style.display === "none");

            rows.forEach(cell => {
                let row = cell.closest("tr");
                if (row) {
                    row.style.display = isHidden ? "table-row" : "none";
                }
            });

            this.textContent = isHidden ? "Ukryj Przerwe Bisową" : "Pokaż Przerwę Bisową";
        });

        // Główna funkcja init()
        async function init() {
            const brygadaType = sessionStorage.getItem('BrygadaType');

            sessionStorage.removeItem('godzina');
            checkLogin();
            loadBrygadaTitle();
            loadBrygadaType();
            fetchDate();



            let lines = await fetchGOTOWEFile();
            if (lines) {
                await processGOTOWEData(lines);
                if (brygadaType == "Brygada Dwuzmianowa") {
                    await addPodmianaRows(); // 🛑 Poczekaj, aż wiersz z podmianą zostanie dodany!
                }
                ZjazdDoZajezdni();
                WyjazdNaLinie();
                await brygadabisowa();

                PrzejazdTechniczny();
                highlightCurrentTimeCells();
                checkAndAddRow(); // 🟢 Teraz uzupełnij tabelę wykazu!
                checkForPodmiana();
                checkForBrake();
                checkForHighlitghtedRow();
                checkForPT();
                checkForWNLZDZ();
                checkForPrzerwaBisowa();
                await scanTableForLine1(); // Poczekaj na zakończenie scanTableForLine1
                usunZakazaneSlowaICyfry();
                sprawdzTekstPoP();
                loadAndRenderTable();
                loadBrygadaType();
                setTimeout(() => {
                    sprawdzBrygadeWTabeli();
                }, 500);

                setInterval(async () => {

                    sprawdzBrygadeWTabeli();
                    await loadAndRenderTable();
                    sprawdzBrygadeWTabeli();




                    console.log("Tabela odświeżona");
                }, 5000);



            } else {
                console.error("Nie udało się wczytać GOTOWE.txt.");
                //window.location.href = 'zoltakartka.html';

            }
        }

        /*
         */

        let modelMap = [];
        let activeFilter = null;
        let activeDelaySort = '';
        let activeLineFilter = '';
        let activeBusNumberFilter = '';
        let wartoscdnia = "2"; // domyślnie np. "Powszedni"



        function parseModelFile(text) {
            modelMap = [];
            const lines = text.trim().split('\n');

            for (const line of lines) {
                const trimmed = line.trim();
                if (/^-{3,}.*-{3,}$/.test(trimmed)) {
                    modelMap.push({
                        model: trimmed,
                        entries: [],
                        display: '',
                        count: 0,
                        isCategory: true
                    });
                    continue;
                }

                const [rangePart, model] = trimmed.split('\t').map(s => s.trim());
                const entries = [];

                if (rangePart.includes(',')) {
                    entries.push(...rangePart.split(',').map(num => parseInt(num.trim(), 10)));
                } else if (rangePart.includes('-')) {
                    const [from, to] = rangePart.split('-').map(s => parseInt(s.trim(), 10));
                    for (let i = from; i <= to; i++) {
                        entries.push(i);
                    }
                } else if (!isNaN(rangePart)) {
                    entries.push(parseInt(rangePart, 10));
                }
                modelMap.push({
                    model,
                    entries,
                    display: rangePart,
                    count: 0,
                    isCategory: false
                });
            }
        }

        function updateModelCounts(vehicles) {
            modelMap.forEach(m => m.count = 0);
            for (const v of vehicles) {
                const nb = parseInt(v.getAttribute("nb"), 10);
                const matched = modelMap.find(entry => !entry.isCategory && entry.entries.includes(nb));
                if (matched) matched.count++;
            }
        }



        function parseDelay(text) {
            const match = text.match(/([-+])(\d{2}):(\d{2})/);
            if (!match) return 0;
            const sign = match[1] === '+' ? 1 : -1;
            const minutes = parseInt(match[2], 10);
            const seconds = parseInt(match[3], 10);
            return sign * (minutes * 60 + seconds);
        }

        function LoadBrygada(godzinaOdjazdu, kierunek, dzien, callback) {
            fetch(`/api/brygadaStrona?godzina=${encodeURIComponent(godzinaOdjazdu)}&kierunek=${encodeURIComponent(kierunek)}&dzien=${encodeURIComponent(dzien)}`)

                .then(response => response.json())
                .then(data => {
                    console.log('Dane otrzymane od serwera:', data);
                    // Przekazanie obu wartości do callbacka
                    callback(data.brygada, data.linia); // Przekazanie również linia
                })
                .catch(error => {
                    console.error('Błąd przy pobieraniu danych:', error);
                    callback('Błąd');
                });
        }



        function loadAndRenderTable() {
            // Pobranie pełnej ścieżki do pliku
            const fullPath = window.location.pathname;

            // Podzielenie ścieżki na części na podstawie "/"
            const pathParts = fullPath.split('/');

            // Pobranie nazwy folderu (zakładamy, że folder jest bezpośrednio nad plikiem)
            const folderName = pathParts[pathParts.length - 2]; // -2, bo ostatni element to nazwa pliku

            // Inicjalizacja zmiennej brygadaNumber na podstawie folderu
            let dzien = ChoosedTypeOfRozklad;




            const scrollTop = window.scrollY;
            const activeElement = document.activeElement;
            const wasFocused = activeElement?.tagName === 'SELECT' || activeElement?.tagName === 'INPUT';

            fetch('/api/vehicles')
                .then(response => response.text())
                .then(xmlString => {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
                    const vehicles = Array.from(xmlDoc.getElementsByTagName("V"));

                    vehicles.sort((a, b) => {
                        const nbA = parseInt(a.getAttribute("nb")) || 0;
                        const nbB = parseInt(b.getAttribute("nb")) || 0;
                        return nbA - nbB;
                    });

                    updateModelCounts(vehicles);

                    const tbody = document.getElementById("dane-wykaz");
                    tbody.innerHTML = "";

                    vehicles.forEach(v => {
                        const nb = v.getAttribute("nb");
                        const nr = v.getAttribute("nr") || '';
                        let op = v.getAttribute("op") || '';
                        const nop = v.getAttribute("nop") || '';
                        let p = v.getAttribute("p") || '';
                        const o = parseInt(v.getAttribute("o"), 10);
                        const isDelayed = o < 0;
                        const absO = Math.abs(o);
                        const minutes = Math.floor(absO / 60);
                        const seconds = absO % 60;
                        const formattedDelay = `${isDelayed ? '-' : '+' }${String(minutes).padStart(2, '0' )}:${String(seconds).padStart(2, '0' )}`;
                        const totalSeconds = (isDelayed ? -1 : 1) * (minutes * 60 + seconds);
                        let color = "#ffffff";
                        if (totalSeconds >= 1) {
                            color = "#0e8616";
                        } else if (totalSeconds < 0 && totalSeconds >= -300) {
                            color = "#ffbb00";
                        } else if (totalSeconds < -300 && totalSeconds >= -600) {
                            color = "#ff8000";
                        } else if (totalSeconds < -600 && totalSeconds >= -1200) {
                            color = "#ff0000";
                        } else if (totalSeconds < -1200) {
                            color = "#a80000";
                        }
                        const formattedTimeReal = `<span style="color: ${color}">${formattedDelay}</span>`;

                        if ((!nr || nr.trim() === '') && (!op || op.trim() === '') && (!p || p.trim() === '')) {
                            op = nop;

                            const now = new Date();
                            now.setSeconds(now.getSeconds() + totalSeconds);

                            if (now.getSeconds() >= 0 && now.getSeconds() < 30) {
                                now.setSeconds(0);
                            } else if (now.getSeconds() >= 30 && now.getSeconds() < 60) {
                                now.setMinutes(now.getMinutes() + 1);
                                now.setSeconds(0);
                            }
                            const hours = now.getHours().toString().padStart(2, '0');
                            const mins = now.getMinutes().toString().padStart(2, '0');
                            p = `${hours}:${mins}`;
                        }
                        const nbNum = parseInt(nb, 10);
                        const matched = modelMap.find(entry => !entry.isCategory && entry.entries.includes(nbNum));
                        const model = matched ? matched.model : 'N/A';

                        // Jeśli kierunek zawiera "p.", to umieszczamy resztę w <span>
                        let formattedOp = op;
                        const pIndex = op.toLowerCase().indexOf("p.");
                        if (pIndex !== -1) {
                            const before = op.slice(0, pIndex).trim();
                            const after = op.slice(pIndex).trim();
                            formattedOp = `${before} <br> <span>${after}</span>`;
                        }

                        const row = document.createElement("tr");
                        row.innerHTML = `
                                            <td>${nb}</td>
                                            <td style="display: none;">${model}</td>
                                            <td>${formattedTimeReal}</td>
                                            <td>${nr}</td>
                                            <td>${formattedOp}</td>
                                            <td style="display: none;">${nop}</td>
                                            <td>${p}</td>
                                            `;

                        tbody.appendChild(row);

                        const godzinaOdjazdu = row.cells[6].textContent.trim();
                        const kierunek = row.cells[4].textContent.trim();
                        const cellBrygada = row.insertCell(2);
                        const cellLinie = row.cells[4];

                        // Funkcja LoadBrygada, która zwraca brygadę i linię
                        LoadBrygada(godzinaOdjazdu, kierunek, dzien, function(brygada, linia) {


                            // Sprawdzamy, czy brygada zawiera "Folder:" i usuwamy go
                            if (brygada.includes("Folder:")) {
                                brygada = brygada.replace("Folder:", "").trim(); // Usuwamy "Folder:" i przycinamy nadmiarowe spacje
                            }

                            // Zamiana "_" na "/"
                            brygada = brygada.replace(/_/g, "/");

                            // Ustawienie brygady w komórce
                            cellBrygada.textContent = brygada;




                            // Sprawdzamy, czy komórka "linie" zawiera jakąkolwiek wartość (nie jest pusta)
                            if (cellLinie.textContent.trim() === "") {
                                // Nadpisanie wartości linii, jeśli komórka nie jest pusta
                                cellLinie.textContent = linia;
                                // Zmiana koloru na różowy
                                cellLinie.style.color = 'grey';

                                // Zmiana koloru również w kolumnie Kierunek
                                const cellKierunek = row.cells[5];
                                cellKierunek.style.color = 'grey';

                                const cellOpoznienie = row.cells[3];
                                cellOpoznienie.style.color = 'white';
                            }

                        });

                    });



                    if (wasFocused) {
                        activeElement?.focus();
                    }

                    window.scrollTo({
                        top: scrollTop
                    });
                })
                .catch(error => {
                    console.error('Błąd przy pobieraniu danych:', error);
                });
        }



        function sprawdzDostepnosc() {
            console.log("Sprawdzanie dostępności...");

        }









        function sprawdzBrygadeWTabeli() {
            const brygadaType = sessionStorage.getItem('brygadaTitle');
            if (!brygadaType) {
                console.log("Brak wartości BrygadaType w sessionStorage.");
                return;
            }

            const brygadaNormalized = brygadaType.replace(/_/g, "/");
            console.log("Szukana brygada:", brygadaNormalized);

            const tabela = document.getElementById("awykazstrony");
            const wiersze = tabela.querySelectorAll("tbody tr");
            let znalezionyWiersz = null;

            wiersze.forEach(row => {
                const komorkaBrygady = row.cells[2]; // kolumna Brygada
                if (komorkaBrygady && komorkaBrygady.textContent.trim() === brygadaNormalized) {
                    znalezionyWiersz = row;
                }
            });

            const naglowek = document.getElementById("pojazdlive");

            if (znalezionyWiersz) {
                const numerAutobusu = znalezionyWiersz.cells[0].textContent.trim();
                console.log("Znaleziono wartość");
                naglowek.textContent = `Autobus zalogowany do brygady: ${numerAutobusu}`;
            } else {
                console.log("Nie ma");
                naglowek.innerHTML = 'Autobus zalogowany do brygady: <span style="color: grey;">brak</span>';

            }
        }

        /*
         */

        document.addEventListener("DOMContentLoaded", async () => {
            const miasto = localStorage.getItem("Miasto");
            if (!miasto) return;

            const header = document.querySelector("header");
            if (!header) return;

            async function fetchTextFile(path) {
                const response = await fetch(path);
                return await response.text();
            }

            function parseMiasta(txt, szukaneMiasto) {
                txt = txt.replace(/\r/g, '');
                const bloki = txt.split('\n\n');
                for (const blok of bloki) {
                    const linie = blok.trim().split('\n');
                    if (linie[0].trim() === szukaneMiasto) {
                        const widoczneMenu = {};
                        for (let i = 2; i < linie.length; i++) {
                            const [klucz, wartosc] = linie[i].split(':').map(s => s.trim());
                            widoczneMenu[klucz] = (wartosc.toUpperCase() === 'TAK');
                        }
                        return widoczneMenu;
                    }
                }
                return {};
            }

            function normalizeKey(s) {
                return s.toLowerCase().trim();
            }

            try {
                const miastaText = await fetchTextFile("../../miasta.txt");
                const doDodania = parseMiasta(miastaText, miasto);

                const doDodaniaNormalized = {};
                for (const key in doDodania) {
                    doDodaniaNormalized[normalizeKey(key)] = doDodania[key];
                }

                const zawszeAktywne = [
                    "wybór miasta",
                    "panel główny",
                    "opuść panel"
                ];

                const linki = header.querySelectorAll("a.menu");
                linki.forEach(link => {
                    const tekst = link.textContent.trim();
                    const normTekst = normalizeKey(tekst);

                    if (zawszeAktywne.includes(normTekst)) {
                        link.style.color = "";
                        link.style.pointerEvents = "";
                        link.style.opacity = "";
                        return;
                    }

                    if (normTekst in doDodaniaNormalized) {
                        if (doDodaniaNormalized[normTekst]) {
                            link.style.color = "";
                            link.style.pointerEvents = "";
                            link.style.opacity = "";
                        } else {
                            link.style.color = "gray";
                            link.style.pointerEvents = "none";
                            link.style.opacity = "0.5";
                        }
                    } else {
                        link.style.color = "gray";
                        link.style.pointerEvents = "none";
                        link.style.opacity = "0.5";
                    }
                });

                const logoutBtn = document.getElementById('logout');
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', function() {
                        const miasto = localStorage.getItem('Miasto');
                        localStorage.clear();
                        localStorage.setItem('Miasto', miasto);
                        window.location.href = 'index.html';
                    });
                }
            } catch (error) {
                console.error("Błąd podczas ładowania danych:", error);
            }
        });

        /*
         */

        document.addEventListener("DOMContentLoaded", async () => {
            const miasto = localStorage.getItem("Miasto");
            if (!miasto) return;

            // Prosta funkcja fetch i odczyt pliku tekstowego
            async function fetchTextFile(path) {
                const response = await fetch(path);
                return await response.text();
            }

            // Parsowanie pliku miasta.txt, szuka sekcji po nazwie miasta i zwraca klucz 'Pojazdy LIVE' jako bool
            function parseMiasta(txt, szukaneMiasto) {
                txt = txt.replace(/\r/g, '');
                const bloki = txt.split('\n\n');
                for (const blok of bloki) {
                    const linie = blok.trim().split('\n');
                    if (linie[0].trim() === szukaneMiasto) {
                        for (let i = 2; i < linie.length; i++) {
                            const [klucz, wartosc] = linie[i].split(':').map(s => s.trim());
                            if (klucz.toLowerCase() === "pojazdy live") {
                                return wartosc.toUpperCase() === 'TAK';
                            }
                        }
                    }
                }
                return true; // domyślnie pokazuj
            }

            try {
                const miastaText = await fetchTextFile("../../miasta.txt");
                const pojazdyLiveAktywne = parseMiasta(miastaText, miasto);

                if (!pojazdyLiveAktywne) {
                    const h3 = document.getElementById("pojazdlive");
                    if (h3) h3.style.display = "none";
                }
            } catch (error) {
                console.error("Błąd podczas ładowania danych:", error);
            }
        });

        async function fetchDate() {
            try {
                const response = await fetch(`../../../Brygady/${Miasto}/WYNIKI/Gotowe_brygady/wazny_od.txt`);
                if (!response.ok) {
                    throw new Error('Błąd podczas ładowania daty');
                }
                const dateText = await response.text();
                document.getElementById('waznyOd').textContent = dateText.trim();
            } catch (error) {
                console.error('Błąd:', error);
                document.getElementById('waznyOd').textContent = 'Błąd ładowania daty';
            }
        }

    </script>
</body>

</html>




<!--


 function drukujRozklad() {
            // Pobranie numeru linii (zawsze oddzielony przecinkiem)
            const nrLinii = Array.from(new Set(
                    [...document.querySelectorAll("#rozkładTable tbody tr td:nth-child(2)")].map(cell => cell.innerText.trim())
                ))
                .sort((a, b) => a - b) // Sortowanie od najmniejszej do największej
                .join(", ") || "Brak!"; // Domyślna wartość, jeśli brak


            // Pobranie wartości brygady z sessionStorage
            let nrBrygada = "NR_BRYGADA"; // Domyślna wartość

            const brygadaTitle = sessionStorage.getItem('brygadaTitle');
            if (brygadaTitle) {
                const formattedTitle = brygadaTitle.replace(/_/g, '/');
                nrBrygada = `${formattedTitle}`;
            } else {
                console.error("Nie znaleziono brygadaTitle w sessionStorage.");
            }
            debugger;
            console.log("Numer linii wysyłany do serwera:", nrLinii);


            fetch('/getRouteStops', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        nrLinii: nrLinii
                    }) // Wysyłamy nrLinii do serwera
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Odpowiedź z serwera:', data); // Logowanie odpowiedzi
                    if (data.stops && Array.isArray(data.stops)) {
                        // Tylko wtedy, gdy odpowiedź zawiera poprawne dane
                        updateTable(data.stops); // Funkcja do aktualizacji tabeli
                    } else {
                        console.error('Błąd: Brak przystanków w odpowiedzi');
                    }
                })
                .catch(error => {
                    console.error("Błąd w wysyłaniu numeru linii:", error);
                });


            function updateTable(przystanki) {
                // Znajdź tabelę i ciało tabeli
                const tabela = document.querySelector("#rozkładTable");
                const tbody = tabela.querySelector("tbody");

                // Usuń istniejące wiersze w tabeli
                tbody.innerHTML = '';

                // Dodaj nowe wiersze na podstawie przystanków
                przystanki.forEach((przystanek, index) => {
                    const tr = document.createElement("tr");

                    const td1 = document.createElement("td");
                    td1.innerText = index + 1; // Numer porządkowy przystanku
                    tr.appendChild(td1);

                    const td2 = document.createElement("td");
                    td2.innerText = przystanek; // Nazwa przystanku
                    tr.appendChild(td2);

                    tbody.appendChild(tr); // Dodaj wiersz do ciała tabeli
                });
            }



            // Pobranie wartości "ChoosedTypeOfDay" z sessionStorage
            let choosedTypeOfDay = sessionStorage.getItem('ChoosedTypeOfDay') || "2"; // Domyślna wartość to "2" (Rozkład ROBOCZY), jeśli brak

            // Zmienna choosedTypeOfDay z mapowaniem wartości
            switch (choosedTypeOfDay) {
                case "1":
                    choosedTypeOfDay = "Rozkład NIEDZIELNY";
                    break;
                case "2":
                    choosedTypeOfDay = "Rozkład ROBOCZY";
                    break;
                case "3":
                    choosedTypeOfDay = "Rozkład WAKACYJNY";
                    break;
                case "4":
                    choosedTypeOfDay = "Rozkład SOBOTNI";
                    break;
                default:
                    choosedTypeOfDay = "Error"; // Domyślnie, jeśli wartość jest nieznana
                    break;
            }


            // Pobranie zawartości tabeli
            const tabela = document.querySelector("#rozkładTable")?.outerHTML || "<p>Brak danych w tabeli</p>";

            // Pobranie daty z serwera
            fetch('/getDateFrom')
                .then(response => response.text())
                .then(dateFrom => {
                    const ilKm = document.querySelector("#kilometers")?.innerText || "IL_KM";

                    // Tworzenie nowego okna do druku
                    const oknoDrukowania = window.open("", "_blank");
                    oknoDrukowania.document.write(`
<html>

<head>
    <title>Rozkład do Druku</title>
    <style>
        @page {
            size: A5 portrait;
            margin: 0.5cm;
        }

        body {
            font-family: Arial, sans-serif;
            font-size: 12px;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid black;
            position: relative;
        }

        .header {
            position: absolute;
            top: 0.5cm;
            left: 0.5cm;
            width: 2.8cm;
            height: 0.5cm;
            border: 1px solid black;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #nr_linii {
            position: absolute;
            top: 1.0cm;
            left: 0.5cm;
            width: 2.8cm;
            height: calc(1.5cm + 2px);
            border-top: none;
            border-left: 1px solid black;
            border-right: 1px solid black;
            border-bottom: 1px solid black;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .data_waznosci {
            position: absolute;
            top: 0.5cm;
            left: calc(3.3cm + 1px);
            width: 2.5cm;
            height: 1cm;
            border: 1px solid black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 0 5px;
        }

        .data_waznosci span {
            display: block;
        }

        .data_waznosci_duplikat {
            position: absolute;
            top: calc(1.5cm + 2px - 1px);
            left: calc(3.3cm + 1px);
            width: 2.5cm;
            height: 1cm;
            border: 1px solid black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 0 5px;
        }

        .data_waznosci_duplikat span {
            display: block;
        }

        .duzy_prostokat {
            position: absolute;
            top: 0.5cm;
            left: calc(5.8cm + 1px + 10px + 1px);
            width: 4.25cm;
            height: calc(1.8cm - 2px);
            border: 1px solid black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 5px;
        }

        .duzy_prostokat span {
            display: block;
            margin-bottom: 3px;
        }

        .nowy_prostokat {
            position: absolute;
            top: 0.5cm;
            right: 0.5cm;
            width: 3.5cm;
            height: 1.5cm;
            border: 1px solid black;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .nowy_prostokat span {
            display: block;
            font-weight: bold;
        }

        .header2 {
            position: absolute;
            top: calc(2.0cm + 1px);
            right: 0.5cm;
            width: 3.5cm;
            height: 0.5cm;
            border: 1px solid black;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .Start {
            position: absolute;
            top: calc(2.5cm + 2px);
            right: 0.5cm;
            width: 13.65cm;
            height: 0.5cm;
            border: 1px solid black;
            display: flex;
            justify-content: left;
            align-items: center;
            text-align: center;
        }

        .End {
            width: 13.65cm;
            height: 0.5cm;
            border: 1px solid black;
            display: flex;
            justify-content: left;
            align-items: center;
            text-align: center;
        }

        .Przerwa1 {
            position: absolute;
            top: calc(3cm + 3px);
            right: 0.5cm;
            width: 13.65cm;
            height: 0.20cm;
            border: 1px solid black;
            display: flex;
            justify-content: left;
            align-items: center;
            text-align: center;
        }

        .Przerwa {
            width: 13.65cm;
            height: 0.25cm;
            border: 1px solid black;
            display: flex;
            justify-content: left;
            align-items: center;
            text-align: center;
        }

        .rozklad {
            width: 90%;
            margin-top: 3.5cm;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            border: 1px solid black;
            text-align: center;
            padding: 5px;
        }

        th {
            background-color: #f2f2f2;
        }

        #rozkładTable{
position: absolute;
        top: 200px;
}
    </style>
</head>

<body>
    <div class="header">
        Linie :
    </div>
    <div id="nr_linii">
        ${nrLinii}
    </div>
    <div class="data_waznosci">
        <span>Ważny od :</span>
        <span>${dateFrom}</span>
    </div>
    <div class="data_waznosci_duplikat">
        <span>Kilometry :</span>
        <span>${ilKm}</span>
    </div>
    <div class="nowy_prostokat">
        <span>${nrBrygada}</span>
    </div>
    <div class="header2">
        <span>${choosedTypeOfDay}</span>
    </div>
    <div class="duzy_prostokat">
        <span>ROZPOCZĘCIE - XX:XX</span>
        <span>ZAKOŃCZENIE - XX:XX</span>
        <span>CZAS PRACA - XX:XX</span>
    </div>
    <div class="Start">
        <span>&nbsp;ROZPOCZĄCIE PRACY - Bardowskiego 04</span>
    </div>
    <div class="Przerwa1">
        <span></span>
    </div>

    <div class="Przerwa">
        <span></span>
    </div>
    <div class="End">
        <span>&nbsp;ZAKOŃCZENIE PRACY - Bardowskiego 04</span>
    </div>
</body>

</html>
            `);
                    oknoDrukowania.document.close();
                    oknoDrukowania.print();
                })
                .catch(error => {
                    console.error("Błąd pobierania daty z serwera:", error);
                });
        }


-->
