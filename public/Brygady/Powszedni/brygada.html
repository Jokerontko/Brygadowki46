<!DOCTYPE html>
<html lang="pl">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.6">
  <link rel="stylesheet" href="../../style_css/headermenu.css">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta http-equiv="refresh" content="180">
  <title>Szczegóły kursu</title>
  <style>
    body {
      background: rgb(50, 50, 50);
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      color: white;
    }

    h1 {
      font-size: 2rem;
      margin: 40px 0 10px;
    }

    table {
      width: 90%;
      max-width: 940px;
      border-collapse: collapse;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 20px;

    }

    th,
    td {
      text-align: center;
      padding: 10px;
      border: 1px solid #ccc;
      font-size: 17px;
    }

    thead {
      background-color: rgba(163, 120, 0);
    }

    .NrOflp {
      text-decoration: none;
      color: orange;
    }

    .hide {
      font-size: 0px;
      padding: 0px;
      border: 0px;
    }

    .Rez {
      padding: 0px;
      text-align: right;
      border-top: 1px solid;
      border-bottom: 1px solid;
      border-left: none;
      border-right: none;

    }

    .RezLP {
      padding: 0px;
      text-align: right;
      border-top: 1px solid;
      border-bottom: 1px solid;
      border-left: 1px solid;
      border-right: none;
    }

    p {
      color: grey;
    }

    #brygadaType {
      margin-top: -5px;
      color: grey;
    }

    #wykazbrygady {
      width: 30%;
    }

    header {
      position: sticky;
      top: 0px;
      background-color: rgb(50, 50, 50);
    }

  </style>
</head>

<body>
  <header>
    <a href="../../Main_Panel.html" class="menu">Panel Główny</a>
    <a href="../ChooseDay.html" class="menu">Brygady</a>
    <a href="../../Brygady/Kursy/Kursy.html" class="menu">Kursy</a>
    <a href="#" class="menu exit" id="logout">Opuść Panel</a>
    <hr>
  </header>

  <h1 id="brygadaTitle">Brygada</h1>
  <h3 id="brygadaType">Typ</h3>

  <a href="#" class="menu" id="highlightButton">Wyróżnij linie</a>

  <table id="wykazbrygady">
    <thead>
      <tr>
        <th>Zmiana</th>
        <th>Godz. Rozp.</th>
        <th>Godz. Zak.</th>
        <th>Czas</th>
        <th>Km</th>
      </tr>
    </thead>
    <tbody id="dane-wykaz">
      <!-- Rows will be added dynamically -->

    </tbody>
  </table>
  <br>



  <table id="rozkładTable">
    <thead>
      <tr>
        <th>Lp</th>
        <th>Linia</th>
        <th>Początek</th>
        <th>Kierunek</th>
        <th>Godz. Rozp.</th>
        <th>Godz. Zak.</th>
        <th>Czas trwania</th>
        <th>Km</th>
        <th class="hide">Kod Trasy</th>
      </tr>
    </thead>
    <tbody id="dane-tabeli">
      <!-- Rows will be added dynamically -->
    </tbody>
  </table>

  <p>Strona odświeża się automatycznie co 180 sekund.</p>

  <script>
    // Check if the user is logged in, otherwise redirect
    function checkLogin() {
      const user = JSON.parse(sessionStorage.getItem('user'));
      if (!user) {
        window.location.href = '../../zoltakartka.html';
      }
    }

    // Set the title for the brigade
    function loadBrygadaTitle() {
      const brygadaTitle = sessionStorage.getItem('brygadaTitle');
      if (brygadaTitle) {
        const formattedTitle = brygadaTitle.replace(/_/g, '/');
        document.getElementById('brygadaTitle').innerText = `Szczegóły brygady: ${formattedTitle}`;
      } else {
        console.error("Nie znaleziono brygadaTitle w sessionStorage.");
      }
    }

    // Set the type for the brigade
    function loadBrygadaType() {
      const brygadaType = sessionStorage.getItem('BrygadaType');
      if (brygadaType) {
        document.getElementById('brygadaType').innerText = `${brygadaType}`;
      } else {
        console.error("Nie znaleziono brygadaTitle w sessionStorage.");
      }
    }

    // Logout logic
    document.getElementById('logout').addEventListener('click', function() {
      sessionStorage.clear();
      window.location.href = '../../index.html';
    });

    // Fetch the 'GOTOWE.txt' file
    async function fetchGOTOWEFile() {
      const brygadaTitle = sessionStorage.getItem('brygadaTitle');
      if (!brygadaTitle) {
        console.error("Nie znaleziono brygadaTitle w sessionStorage.");
        return null;
      }

      let filePath = `../../../Brygady/WYNIKI/Gotowe_brygady/${brygadaNumber}/${brygadaTitle}/GOTOWE.txt`;
      try {
        const response = await fetch(filePath);
        if (!response.ok) {
          throw new Error(`Sieć odpowiedziała błędem: ${response.status}`);
        }
        const text = await response.text();
        return text.split("\n");
      } catch (error) {
        console.error('Błąd podczas odczytu pliku GOTOWE.txt:', error);
        return null;
      }
    }

    // Fetch the 'Kierunki.txt' file
    async function fetchKierunkiFile() {
      const filePath = "../../../Brygady/WYNIKI/Kierunki.txt";
      try {
        const response = await fetch(filePath);
        if (!response.ok) {
          throw new Error(`Sieć odpowiedziała błędem: ${response.status}`);
        }
        const text = await response.text();
        return text.split("\n");
      } catch (error) {
        console.error('Błąd podczas odczytu pliku Kierunki.txt:', error);
        return null;
      }
    }

    // Build a map from the Kierunki file
    function buildKierunkiMap(lines) {
      const kierunkiMap = new Map();
      lines.forEach((line) => {
        const parts = line.split("\t");
        if (parts.length >= 2) {
          const linia = parts[0].trim();
          const numerLiniiMatch = parts[1].match(/\[([^\]]+)\]/);
          if (numerLiniiMatch) {
            const numerLinii = numerLiniiMatch[1];
            kierunkiMap.set(linia, numerLinii);
          }
        }
      });
      return kierunkiMap;
    }

    // Normalize time to a standard format (HH:MM)
    function normalizeTime(time) {
      const [hours, minutes] = time.split(':').map(Number);
      const normalizedHours = hours >= 24 ? hours - 24 : hours;
      return `${String(normalizedHours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }

    // Function to calculate time duration between start and end times (in minutes)
    function calculateDuration(startTime, endTime) {
      const [startHours, startMinutes] = startTime.split(":").map(Number);
      const [endHours, endMinutes] = endTime.split(":").map(Number);

      let durationHours = endHours - startHours;
      let durationMinutes = endMinutes - startMinutes;

      if (durationMinutes < 0) {
        durationMinutes += 60;
        durationHours -= 1;
      }

      if (durationHours < 0) {
        durationHours += 24; // Handle crossing midnight
      }

      return durationHours * 60 + durationMinutes; // Return duration in minutes
    }

    // Function to remove numbers from a string
    function removeNumbers(str) {
      return str.replace(/[0-9]/g, '').trim();
    }

    // Function to check if current time is between start and end times, handling midnight crossing
    function isCurrentTimeBetween(startTime, endTime) {
      const currentTime = new Date();
      const currentHours = currentTime.getHours();
      const currentMinutes = currentTime.getMinutes();
      const currentFormattedTime = `${String(currentHours).padStart(2, '0')}:${String(currentMinutes).padStart(2, '0')}`;

      // Convert times to minutes from midnight for easier comparison
      const getMinutesFromMidnight = (time) => {
        const [hours, minutes] = time.split(':').map(Number);
        return hours * 60 + minutes;
      };

      const startMinutes = getMinutesFromMidnight(startTime);
      const endMinutes = getMinutesFromMidnight(endTime);
      const currentMinutesFromMidnight = getMinutesFromMidnight(currentFormattedTime);

      // Case when end time is after start time
      if (startMinutes < endMinutes) {
        return currentMinutesFromMidnight >= startMinutes && currentMinutesFromMidnight <= endMinutes;
      } else {
        // Case when end time is before midnight (crossing midnight)
        return (
          currentMinutesFromMidnight >= startMinutes || currentMinutesFromMidnight <= endMinutes
        );
      }
    }

    // Function to check if currentTime is between startTime and endTime, handling midnight crossing
    function isTimeBetween(currentTime, startTime, endTime) {
      if (startTime < endTime) {
        return currentTime > startTime && currentTime < endTime;
      } else {
        return currentTime > startTime || currentTime < endTime;
      }
    }

    function highlightCurrentTimeCells() {
      const tableRows = document.querySelectorAll("#rozkładTable tbody tr");
      let anyHighlighted = false; // Flag to check if any row is highlighted

      tableRows.forEach(row => {
        const startCell = row.cells[4]; // Godz. Rozp.
        const endCell = row.cells[5]; // Godz. Zak.

        if (startCell && endCell) {
          const startTime = normalizeTime(startCell.innerText);
          const endTime = normalizeTime(endCell.innerText);
          console.log(`Start time: ${startTime}, End time: ${endTime}`); // Logging

          // If current time is between start and end time, highlight the row
          if (isCurrentTimeBetween(startTime, endTime)) {
            row.style.backgroundColor = "rgb(75, 75, 75)";
            anyHighlighted = true; // If any row is highlighted, set the flag
          } else {
            row.style.backgroundColor = ""; // Reset the background if not in range
          }
        }
      });

      // If no row is highlighted, add a new row
      if (!anyHighlighted) {
        insertNewRowBetweenNearestTimes();
      }
    }

    // Function to insert a new row between the nearest "Godz. Zak." and "Godz. Rozp."
    function insertNewRowBetweenNearestTimes() {
      const tableBody = document.querySelector("#rozkładTable tbody");
      const tableRows = Array.from(tableBody.rows); // Convert NodeList to array

      let closestStartTime = null;
      let closestEndTime = null;
      let insertIndex = -1;
      let brake = 0; // Time difference between times

      for (let i = 0; i < tableRows.length - 1; i++) {
        const currentRow = tableRows[i];
        const nextRow = tableRows[i + 1];

        // Ensure that both startCell and endCell exist in the current and next rows
        const startCell = currentRow.cells[4]; // Godz. Rozp.
        const endCell = currentRow.cells[5]; // Godz. Zak.
        const nextStartCell = nextRow.cells[4]; // Godz. Rozp. in the next row

        if (startCell && endCell && nextStartCell) { // Check if cells exist
          const startTime = normalizeTime(startCell.innerText);
          const endTime = normalizeTime(endCell.innerText);
          const nextStartTime = normalizeTime(nextStartCell.innerText); // Next row's start time

          if (closestStartTime === null || (isCloserToCurrentTime(startTime, closestStartTime) && isCloserToCurrentTime(endTime, closestEndTime))) {
            closestStartTime = startTime;
            closestEndTime = endTime;
            insertIndex = i + 1; // Insert after the current row

            // Calculate time difference (Brake) between start and end time
            brake = calculateDuration(startTime, endTime);
          }
        }
      }

      // Insert the new row only if insertIndex is set (i.e. valid insertion point)
      if (insertIndex !== -1) {
        const nextRow = tableRows[insertIndex]; // Row below which the new row will be inserted
        const nextStartCell = nextRow.cells[4]; // Godz. Rozp. in the next row
        const nextStartTime = normalizeTime(nextStartCell.innerText); // Next start time

        // New row's start time is the next row's start time
        const newStartTime = nextStartTime;
        const newEndTime = closestEndTime; // End time remains the same as the previous row

        // Calculate time difference (Brake) between newStartTime and closestEndTime
        const timeDifference = calculateDuration(closestEndTime, newStartTime);

        // Calculate remaining time (brakeleft)
        const currentTime = new Date();
        const currentTimeFormatted = normalizeTime(`${String(currentTime.getHours()).padStart(2, '0')}:${String(currentTime.getMinutes()).padStart(2, '0')}`);
        const remainingTime = calculateDuration(currentTimeFormatted, newStartTime);

        // Check if current time is between newEndTime and newStartTime and if brakeleft is valid
        if (isTimeBetween(currentTimeFormatted, newEndTime, newStartTime)) {
          const brakeleft = remainingTime;
          if (brakeleft < timeDifference) {
            // brakeleft is the difference between brake and remaining time
            const newRow = document.createElement("tr");
            newRow.innerHTML = `
                    <td colspan="8" style="background-color: rgb(75, 75, 75); text-align: center; font-size: 15px; padding: 3px;">
                        Trwa przerwa ${timeDifference} min., pozostało: <strong> ${brakeleft} min.</strong>
                    </td>
                `;
            tableBody.insertBefore(newRow, tableBody.rows[insertIndex]);
          }
        } else {
          // If the condition is not met, stop further execution
          return;
        }
      } else {
        // If insertIndex is -1, stop execution (no valid row to insert)
        return;
      }
    }


    // Function to compare which time is closer to the current time
    function isCloserToCurrentTime(time1, time2) {
      const currentTime = new Date();
      const currentFormatted = normalizeTime(`${String(currentTime.getHours()).padStart(2, '0')}:${String(currentTime.getMinutes()).padStart(2, '0')}`);

      const time1Diff = calculateDuration(currentFormatted, time1);
      const time2Diff = calculateDuration(currentFormatted, time2);

      return time1Diff < time2Diff;
    }




    // Helper function to calculate time difference in minutes, handling midnight crossing
    function calculateTimeDifference(startTime, endTime) {
      const [startHours, startMinutes] = startTime.split(":").map(Number);
      const [endHours, endMinutes] = endTime.split(":").map(Number);
      const startTotal = startHours * 60 + startMinutes;
      const endTotal = endHours * 60 + endMinutes;
      let diff = endTotal - startTotal;
      if (diff < 0) {
        diff += 24 * 60; // Add 24 hours if end time is before start time
      }
      return diff;
    }

    // Helper function to check which time is closer to the current time
    function isCloserToCurrentTime(time1, time2) {
      const currentTime = new Date();
      const currentMinutes = currentTime.getHours() * 60 + currentTime.getMinutes();

      const time1Minutes = time1.split(":").map(Number).reduce((acc, time) => acc * 60 + time);
      const time2Minutes = time2.split(":").map(Number).reduce((acc, time) => acc * 60 + time);

      const diff1 = Math.min(Math.abs(currentMinutes - time1Minutes), 1440 - Math.abs(currentMinutes - time1Minutes));
      const diff2 = Math.min(Math.abs(currentMinutes - time2Minutes), 1440 - Math.abs(currentMinutes - time2Minutes));

      return diff1 < diff2;
    }

    async function processGOTOWEData(lines) {
      let tableBody = document.querySelector("#rozkładTable tbody");
      let lp = 1;
      let currentRouteId = null;
      let firstStop = null;
      let lastStop = null;
      let startTime = null;
      let endTime = null;
      let tripId = null;

      lines.slice(2).forEach((line) => {
        line = line.trim();

        if (line === "") {
          if (currentRouteId && firstStop && lastStop && startTime && endTime) {
            // Obliczanie różnicy czasu w minutach
            const durationInMinutes = calculateDuration(startTime, endTime);

            // Przekształcenie minut na godziny i minuty
            const hours = Math.floor(durationInMinutes / 60);
            const minutes = durationInMinutes % 60;

            // Formatowanie w formacie HH:MM
            const durationFormatted = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

            let row = document.createElement("tr");
            row.innerHTML +=
              `<td><a class="NrOflp" href="BrygadaSzczegoly.html" onclick="savetripid('${tripId}')" >${lp}.</a></td>
             <td class="NrOfLine">${currentRouteId}</td>
             <td>${firstStop}</td>
             <td>${lastStop}</td>
             <td>${startTime}</td>
             <td>${endTime}</td>
             <td>${durationFormatted}</td>
             <td>N/A</td>
             <td class="hide">${tripId}</td>`;



            tableBody.appendChild(row);
            lp++;
            currentRouteId = null;
            firstStop = null;
            lastStop = null;
            startTime = null;
            endTime = null;
            tripId = null;
          }
        } else if (line.includes("Rezerwa")) {
          // Jeżeli linia zawiera słowo "Rezerwa"
          let parts = line.split("\t").filter(part => part.trim() !== ""); // Filtrujemy puste elementy
          if (parts.length === 6 && parts[1] === "R" && parts[2] === "-") {
            // Zakładamy, że nowy format ma postać: "REZ \t R \t - \t Godz_Rozp \t Godz_Zak \t Rezerwa"
            let godzRozp = parts[3].trim();
            let godzZak = parts[4].trim();
            const czasrezerwa = calculateTimeDifference(godzRozp, godzZak);

            let row = document.createElement("tr");
            row.innerHTML += `
<td class="RezLP"></td>
<td class="Rez"></td>
<td class="Rez">Rezerwa</td>
<td class="Rez"></td>
<td>${godzRozp}</td>
<td>${godzZak}</td>
<td>${czasrezerwa}</td>
<td>N/A</td>`;

            tableBody.appendChild(row);
          }
        } else {
          let parts = line.split(/\s+/);
          let routeId = parts[0]; // Assuming this is the identifier you want
          let arrivalTime = parts[3];
          let stopName = parts.slice(5).join(" ");
          tripId = parts[2]; // Przypisz trip_id

          if (!currentRouteId) {
            currentRouteId = routeId;
            firstStop = stopName;
            startTime = normalizeTime(arrivalTime);
          }
          lastStop = stopName;
          endTime = normalizeTime(arrivalTime);
        }
      });

      // Dodaj ostatni wiersz, jeśli istnieje
      if (currentRouteId && firstStop && lastStop && startTime && endTime) {
        const duration = calculateDuration(startTime, endTime);
        let row = document.createElement("tr");
        row.innerHTML +=
          `<td><a class="NrOflp" href="Szczegoly.html">${lp}.</a></td>
             <td>${currentRouteId}</td>
             <td>${firstStop}</td>
             <td>${lastStop}</td>
             <td>${startTime}</td>
             <td>${endTime}</td>
             <td>${duration}</td>
             <td>N/A</td>
             <td class="hide">${tripId}</td>`;
        tableBody.appendChild(row);
        lp++;
      }









      // Fetch kierunki and update the lines
      const kierunkiLines = await fetchKierunkiFile();
      if (kierunkiLines) {
        const kierunkiMap = buildKierunkiMap(kierunkiLines);
        for (let row of tableBody.rows) {
          const liniaCell = row.cells[1];
          const liniaValue = liniaCell ? liniaCell.innerText : null;
          if (liniaValue && kierunkiMap.has(liniaValue)) {
            liniaCell.innerText = kierunkiMap.get(liniaValue);
          }
        }
      } else {
        console.error("Nie udało się wczytać Kierunki.txt.");
      }
    }

    // Pobranie pełnej ścieżki do pliku
    const fullPath = window.location.pathname;

    // Podzielenie ścieżki na części na podstawie "/"
    const pathParts = fullPath.split('/');

    // Pobranie nazwy folderu (zakładamy, że folder jest bezpośrednio nad plikiem)
    const folderName = pathParts[pathParts.length - 2]; // -2, bo ostatni element to nazwa pliku

    // Inicjalizacja zmiennej brygadaNumber na podstawie folderu
    let brygadaNumber;

    switch (folderName) {
      case 'Niedzielny':
        brygadaNumber = '1';
        break;
      case 'Powszedni':
        brygadaNumber = '2';
        break;
      case 'PowszedniWolny':
        brygadaNumber = '3';
        break;
      case 'Sobotni':
        brygadaNumber = '4';
        break;
      default:
        brygadaNumber = '2'; // Domyślna wartość, jeśli folder nie pasuje do żadnego przypadku
    }

    // Zmienna, która przechowuje stan wyróżnienia
    let isHighlighted = false;
    // Funkcja do wyróżniania unikalnych wartości w kolumnie "Linia"
    function toggleHighlight() {
      const tableRows = document.querySelectorAll("#rozkładTable tbody tr");
      const uniqueLines = new Set();
      const lineColors = {};
      const colors = ["#CD853F", "#778899", "#4169E1", "#20B2AA", "#6A5ACD", "#228B22"];
      let colorIndex = 0;

      // Jeśli jest włączone wyróżnienie, resetujemy kolory i przerywamy funkcję
      if (isHighlighted) {
        tableRows.forEach(row => {
          const lineCell = row.querySelector(".NrOfLine");
          if (lineCell) {
            // Przywracamy oryginalny tekst, który zapisaliśmy w atrybucie data-original-text
            const originalText = lineCell.getAttribute("data-original-text");
            if (originalText) {
              lineCell.innerText = originalText;
            }
          }
        });
        isHighlighted = false;
        document.getElementById("highlightButton").innerText = "Wyróżnij linie"; // Zmień tekst przycisku
        return;
      }

      // Iterujemy przez wiersze, aby zidentyfikować unikalne wartości w kolumnie "Linia"
      tableRows.forEach(row => {
        const lineCell = row.querySelector(".NrOfLine");
        if (lineCell) {
          const lineValue = lineCell.innerText;
          uniqueLines.add(lineValue);
        }
      });

      // Przypisujemy unikalny kolor do każdej unikalnej wartości w kolumnie "Linia"
      uniqueLines.forEach(line => {
        lineColors[line] = colors[colorIndex % colors.length];
        colorIndex++;
      });

      // Ustawiamy kolor tylko dla tekstu w komórce w kolumnie "Linia", na podstawie wartości
      tableRows.forEach(row => {
        const lineCell = row.querySelector(".NrOfLine");
        if (lineCell && lineColors[lineCell.innerText]) {
          const lineValue = lineCell.innerText;

          // Zapisz oryginalny tekst komórki, aby można było go później przywrócić
          if (!lineCell.getAttribute("data-original-text")) {
            lineCell.setAttribute("data-original-text", lineValue);
          }

          // Dodaj `span` z odpowiednim stylem wokół tekstu
          lineCell.innerHTML = `<span class="highlighted-text" style="
                background-color: ${lineColors[lineValue]};
                color: white;
                border-radius: 5px;
                padding: 2px 5px;
                display: inline-block;
            ">${lineValue}</span>`;
        }
      });

      isHighlighted = true;
      document.getElementById("highlightButton").innerText = "Przestań wyróżniać linie"; // Zmień tekst przycisku
    }

    // Dodanie nasłuchu kliknięcia na przycisk "Wyróżnij linie"
    document.getElementById("highlightButton").addEventListener("click", toggleHighlight);
    window.onload = init;

    function savetripid(tripid) {
      sessionStorage.setItem('savedtripid', tripid);
    }

    // Funkcja globalna: Dodawanie wiersza na podstawie warunku
    function checkAndAddRow() {
      const brygadaType = sessionStorage.getItem("BrygadaType");


      if (brygadaType === "Brygada Jednozmianowa" || brygadaType === "Brygada Nocna Jednozmianowa") {
        const tabelaWykaz = document.querySelector("#wykazbrygady #dane-wykaz");
        const tabelaRozklad = document.querySelector("#rozkładTable #dane-tabeli");

        if (!tabelaWykaz || !tabelaRozklad) {
          console.error("Nie znaleziono jednej z wymaganych tabel.");
          return;
        }

        logTableContent(tabelaRozklad); // Dodane dla diagnostyki

        const godzRozp = findFirstAvailableStartTime(tabelaRozklad);
        const godzZak = findLatestEndTime(tabelaRozklad);
        if (!godzRozp || !godzZak) {
          console.error("Nie znaleziono wartości w kolumnach 'Godz. Rozp.' lub 'Godz. Zak.' w tabeli rozkładTable.");
          return;
        }

        const roznica = calculateTimeDifference(godzRozp, godzZak);

        const newRow = document.createElement("tr");
        newRow.innerHTML = `
            <td>A</td>
            <td>${godzRozp}</td>
            <td>${godzZak}</td>
            <td>${roznica}</td>
            <td>N/A</td>
        `;

        tabelaWykaz.appendChild(newRow);
      } else if (brygadaType === "Brygada Dwuzmianowa" || brygadaType === "Brygada Szczytowa") {
        const savedpodmiana = sessionStorage.getItem('godzina');
        const tabelaWykaz = document.querySelector("#wykazbrygady #dane-wykaz");
        const tabelaRozklad = document.querySelector("#rozkładTable #dane-tabeli");

        if (!tabelaWykaz || !tabelaRozklad) {
          console.error("Nie znaleziono jednej z wymaganych tabel.");
          return;
        }

        logTableContent(tabelaRozklad); // Dodane dla diagnostyki

        const godzRozp = findFirstAvailableStartTime(tabelaRozklad);
        const godzZak = findLatestEndTime(tabelaRozklad);
        if (!godzRozp || !godzZak) {
          console.error("Nie znaleziono wartości w kolumnach 'Godz. Rozp.' lub 'Godz. Zak.' w tabeli rozkładTable.");
          return;
        }

        const roznicaA = calculateTimeDifference(godzRozp, savedpodmiana);
        const roznicaB = calculateTimeDifference(savedpodmiana, godzZak);
        const podmiana = 22;

        function createRow(label, godzRozp, godzZak, roznicaA, roznicaB) {
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${label}</td>
            <td>${godzRozp}</td>
            <td>${godzZak}</td>
            <td>${roznicaA}</td>
            <td>N/A</td>
        `;
          return row;
        }

        // Tworzenie dwóch wierszy
        const newRow1 = createRow("A", godzRozp, savedpodmiana, roznicaA);
        const newRow2 = createRow("B", savedpodmiana, godzZak, roznicaB);

        // Dodanie wierszy do tabeli
        tabelaWykaz.appendChild(newRow1);
        tabelaWykaz.appendChild(newRow2);
      }
    }






    // Funkcja globalna: Znajdowanie pierwszej dostępnej wartości w kolumnie "Godz. Rozp."
    function findFirstAvailableStartTime(tabelaRozklad) {
      const rows = tabelaRozklad.querySelectorAll("tr");
      for (const row of rows) {
        const godzRozpCell = row.cells[4]; // Kolumna "Godz. Rozp." (indeks 4)
        if (godzRozpCell && godzRozpCell.textContent.trim()) {
          return godzRozpCell.textContent.trim();
        }
      }
      return null;
    }



    function findLatestEndTime(tabelaRozklad) {
      const rows = Array.from(tabelaRozklad.querySelectorAll("tr")); // Pobieramy wszystkie wiersze tabeli jako tablicę

      // Iterujemy od ostatniego wiersza do pierwszego
      for (let i = rows.length - 1; i >= 0; i--) {
        const godzZakCell = rows[i].cells[5]; // Kolumna "Godz. Zak." (indeks 5)

        // Sprawdzamy, czy komórka zawiera niepustą wartość
        if (godzZakCell && godzZakCell.textContent.trim()) {
          return godzZakCell.textContent.trim(); // Zwracamy pierwszą znalezioną niepustą wartość
        }
      }

      // Jeśli nie znaleziono żadnej wartości, zwracamy null
      return null;
    }


    // Funkcja globalna: Konwersja czasu w formacie HH:MM na minuty od początku dnia
    function convertTimeToMinutes(time) {
      const [hours, minutes] = time.split(":").map(Number);
      return (hours % 24) * 60 + minutes; // Modulo obsługuje godziny po północy
    }




    // Funkcja globalna: Logowanie zawartości tabeli (dla diagnostyki)
    function logTableContent(tabelaRozklad) {
      const rows = tabelaRozklad.querySelectorAll("tr");
      rows.forEach((row, index) => {
        const godzRozpCell = row.cells[4]; // Kolumna "Godz. Rozp." (indeks 4)
        const godzZakCell = row.cells[5]; // Kolumna "Godz. Zak." (indeks 5)
        console.log(`Wiersz ${index + 1}: Rozp: ${godzRozpCell ? godzRozpCell.textContent.trim() : "Brak"} | Zak: ${godzZakCell ? godzZakCell.textContent.trim() : "Brak"}`);
      });
    }

    // Funkcja globalna: Obliczanie różnicy czasu, z obsługą godzin po północy
    function calculateTimeDifference(start, end) {
      const startMinutes = convertTimeToMinutes(start);
      const endMinutes = convertTimeToMinutes(end);

      let diffMinutes;
      if (endMinutes < startMinutes) {
        // Obsługa przejścia przez północ (dodajemy 24 godziny)
        diffMinutes = (endMinutes + 24 * 60) - startMinutes;
      } else {
        diffMinutes = endMinutes - startMinutes;
      }

      const hours = Math.floor(diffMinutes / 60);
      const minutes = diffMinutes % 60;

      return `${hours}:${minutes}`;
    }









    async function addPodmianaRows() {
      try {
        // Uzyskanie ścieżki folderu z URL
        const pathParts = window.location.pathname.split("/"); // Rozdzielenie ścieżki URL na części
        const folderName = pathParts[pathParts.length - 2]; // Nazwa folderu przed nazwą pliku
        console.log("Nazwa folderu:", folderName); // Logowanie nazwy folderu

        // Inicjalizacja zmiennej brygadaNumber na podstawie folderu
        let brygadaNumber;

        switch (folderName) {
          case 'Niedzielny':
            brygadaNumber = '1';
            break;
          case 'Powszedni':
            brygadaNumber = '2';
            break;
          case 'PowszedniWolny':
            brygadaNumber = '3';
            break;
          case 'Sobotni':
            brygadaNumber = '4';
            break;
          default:
            brygadaNumber = '2'; // Domyślna wartość, jeśli folder nie pasuje do żadnego przypadku
        }

        // Pobranie wartości brygadaTitle z sessionStorage
        const brygadaTitle = sessionStorage.getItem("brygadaTitle");
        if (!brygadaTitle) {
          console.error("Nie znaleziono brygadaTitle w sessionStorage.");
          return;
        }

        // Ścieżka do pliku podmiana.txt
        const filePath = `../../../Brygady/WYNIKI/Gotowe_brygady/${brygadaNumber}/${brygadaTitle}/podmiana.txt`;
        console.log("Ścieżka do pliku:", filePath);

        // Wczytanie danych z pliku
        const response = await fetch(filePath, {
          headers: {
            'Content-Type': 'text/plain; charset=UTF-8'
          }
        });
        if (!response.ok) {
          console.error("Nie udało się wczytać pliku podmiana.txt");
          return;
        }

        const text = await response.text();
        const podmianaLines = text.split("\n").map(line => line.trim()).filter(line => line);

        let tableBody = document.querySelector("#rozkładTable tbody");
        if (!tableBody) {
          console.error("Nie znaleziono tabeli z id 'rozkładTable'.");
          return;
        }

        let tableRows = Array.from(tableBody.querySelectorAll("tr"));

        // Przetwarzanie każdej linii z pliku
        podmianaLines.forEach((line) => {
          const [przystanek, godzina] = line.split("\t").map(item => item.trim());
          console.log("Przystanek:", przystanek, "Godzina:", godzina);

          // Przechodzimy przez wiersze tabeli
          for (let i = 0; i < tableRows.length - 1; i++) {
            const currentRow = tableRows[i];
            const nextRow = tableRows[i + 1];

            // Pobieranie godziny rozpoczęcia w bieżącym i następnym wierszu
            let currentTime = currentRow.cells[4]?.textContent; // Godzina rozpoczęcia bieżącego wiersza
            let nextTime = nextRow.cells[4]?.textContent; // Godzina rozpoczęcia następnego wiersza

            console.log("Current Time:", currentTime, "Next Time:", nextTime);

            // Sprawdzamy, czy godzina w następnym wierszu jest null
            if (!nextTime) {
              // Jeśli godzina w następnym wierszu jest null, użyj godziny z wiersza trzeciego
              const thirdRow = tableRows[i + 2];
              nextTime = thirdRow ? thirdRow.cells[4]?.textContent : null;
              console.warn(`Brak godz. rozp. w wierszu ${i + 1}, używam godziny z wiersza ${i + 2}: ${nextTime}`);
            }

            // Sprawdzamy, czy godzina z podmiany jest między godzinami w bieżącym i następnym wierszu
            if (currentTime && nextTime && isBetween(godzina, currentTime, nextTime)) {
              sessionStorage.setItem('godzina', godzina);
              const newRow = document.createElement("tr");
              newRow.innerHTML =
                `<td colspan="9" style="text-align: center; font-size: 15px; padding: 3px;">Podmiana: &nbsp;&nbsp; <strong>${przystanek}</strong> &nbsp;&nbsp; ${godzina}</td>`;

              tableBody.insertBefore(newRow, nextRow);
              break;
            }
          }
        });
      } catch (error) {
        console.error("Wystąpił błąd:", error);
      }
    }

    // Funkcja pomocnicza sprawdzająca, czy czas `value` jest między `start` a `end`
    function isBetween(value, start, end) {
      const [valueH, valueM] = value.split(":").map(Number);
      const [startH, startM] = start.split(":").map(Number);
      const [endH, endM] = end.split(":").map(Number);

      const valueMinutes = valueH * 60 + valueM;
      const startMinutes = startH * 60 + startM;
      const endMinutes = endH * 60 + endM;

      return valueMinutes > startMinutes && valueMinutes < endMinutes;
    }


    function brygadabisowa() {
      const tableBody = document.getElementById("dane-tabeli");
      const rows = tableBody.getElementsByTagName("tr");
      let maxGap = 0;
      let maxGapIndex = -1;
      const brygadaType = sessionStorage.getItem("BrygadaType");


      if (brygadaType === "Brygada Szczytowa") {

        // Funkcja pomocnicza do parsowania czasu (np. "14:30")
        function parseTime(timeString) {
          if (!timeString) return null; // Jeśli null lub pusty, zwróć null
          const [hours, minutes] = timeString.split(":").map(Number);
          return hours * 60 + minutes; // Zwraca czas w minutach 
        }

        // Iteracja przez wiersze tabeli
        for (let i = 0; i < rows.length - 1; i++) {
          const currentRow = rows[i];
          const nextRow = rows[i + 1];

          if (!currentRow || !nextRow) continue; // Upewniamy się, że oba wiersze istnieją

          const endTimeCurrent = currentRow.cells[5]?.textContent.trim(); // "Godz. Zak."
          let startTimeNext = nextRow.cells[4]?.textContent.trim(); // "Godz. Rozp."

          // Jeśli "Godz. Rozp." wiersza następnego jest null, weź wartość z kolejnego wiersza (o ile istnieje)
          if (!startTimeNext && rows[i + 2]) {
            const nextNextRow = rows[i + 2];
            startTimeNext = nextNextRow?.cells[4]?.textContent.trim();
          }

          // Parsowanie czasów
          const endMinutes = parseTime(endTimeCurrent);
          const startMinutes = parseTime(startTimeNext);

          // Jeśli brak jednego z czasów, pomijamy tę parę
          if (endMinutes === null || startMinutes === null) continue;

          const gap = startMinutes - endMinutes;
          if (gap > maxGap) {
            maxGap = gap;
            maxGapIndex = i;
          }
        }

        // Dodanie nowego wiersza z informacją o najdłuższej przerwie
        if (maxGapIndex !== -1) {
          const newRow = document.createElement("tr");
          newRow.innerHTML =
            `<td colspan="9" style="text-align: center; background-color: purple;"> <strong> Przerwa bisowa </strong> (${Math.floor(maxGap / 60)}h ${maxGap % 60}min) </td>`;
          // Wstaw nowy wiersz po wierszu, który ma największą różnicę
          tableBody.insertBefore(newRow, rows[maxGapIndex + 1]);
        }
      }
    }

    function WyjazdNaLinie() {
      const tableBody = document.querySelector("#rozkładTable tbody");
      // Add the "Wyjazd Na Linie" row if needed
      let wyjazdAdded = false;
      if (tableBody.rows.length > 0) {
        const firstPoczątekValue = tableBody.rows[0].cells[2].innerText.trim();
        const wasRezerwa = firstPoczątekValue === "Rezerwa";
        const nextRowPoczątekValue = tableBody.rows[1].cells[2].innerText.trim();

        // Jeśli pierwsza komórka nie jest "Lubelska Zajezdnia MPK"
        if (firstPoczątekValue !== "Lubelska Zajezdnia MPK") {
          // Jeżeli wartość w pierwszej komórce nie jest "Rezerwa" i druga komórka nie zawiera "Lubelska Zajezdnia MPK"
          if (!wasRezerwa || nextRowPoczątekValue !== "Lubelska Zajezdnia MPK") {
            let wyjazdRow = document.createElement("tr");
            let wyjazdCell = document.createElement("td");
            wyjazdCell.colSpan = 9;
            wyjazdCell.innerText = "Wyjazd Na Linie";
            wyjazdCell.style.textAlign = "center"; // Wyśrodkowanie tekstu
            wyjazdRow.appendChild(wyjazdCell);
            tableBody.insertBefore(wyjazdRow, tableBody.rows[0]);
            wyjazdRow.style.backgroundColor = "rgba(163, 120, 0)";
            wyjazdAdded = true;
          }
        }
      }
    }

    function PrzejazdTechniczny() {
      const tableBody = document.querySelector("#rozkładTable tbody");
      // Przejazd Techniczny
      const exceptions = ["Głogów Młp. Leniar I  nż", "Głogów Młp. Leniar I  nż", "Langiewicza / Wita Stwosza", "Wita Stwosza pętla", "Ustrzycka  nż", "Ustrzycka / Magórska "];
      let rowCount = tableBody.rows.length; // Zapisz początkową liczbę wierszy w tabeli

      for (let i = 0; i < rowCount - 1; i++) {
        // Sprawdź, czy to już ostatni wiersz
        if (i === rowCount - 2) {
          break; // Przerywamy działanie pętli, jeśli osiągnęliśmy przedostatni wiersz
        }

        const currentRow = tableBody.rows[i];
        const nextRow = tableBody.rows[i + 1];
        const kierunekValue = currentRow.cells[3] ? currentRow.cells[3].innerText : null;
        let początekValue = nextRow.cells[2] ? nextRow.cells[2].innerText : null;
        let cleanKierunek = kierunekValue ? removeNumbers(kierunekValue).trim() : null;
        let cleanPoczątek = początekValue ? removeNumbers(początekValue).trim() : null;

        // Sprawdzamy, czy cleanPoczątek to "Rezerwa"
        const wasRezerwa = cleanPoczątek === "Rezerwa";

        // Jeśli cleanPoczątek to "Rezerwa", to zaktualizuj go o wartość z kolejnego wiersza (i + 2)
        if (wasRezerwa && tableBody.rows[i + 2]) {
          const nextNextRow = tableBody.rows[i + 2];
          początekValue = nextNextRow.cells[2] ? nextNextRow.cells[2].innerText : null;
          cleanPoczątek = początekValue ? removeNumbers(początekValue).trim() : null;
        }

        // Sprawdzamy, czy cleanKierunek jest różne od cleanPoczątek po aktualizacji
        if (cleanKierunek && cleanPoczątek && cleanKierunek !== cleanPoczątek) {
          let isNotException = true;

          // Sprawdzenie wyjątków
          for (let exception of exceptions) {
            if (cleanKierunek === exception || cleanPoczątek === exception) {
              isNotException = false;
              break;
            }
          }

          // Jeśli nie ma wyjątków, dodaj wiersz "Przejazd Techniczny"
          if (isNotException) {
            let przejazdRow = document.createElement("tr");
            let przejazdCell = document.createElement("td");
            przejazdCell.colSpan = 9;
            przejazdCell.innerText = "Przejazd Techniczny";
            przejazdCell.style.textAlign = "center";
            przejazdRow.appendChild(przejazdCell);

            // Dodaj "Przejazd Techniczny" poniżej tylko w przypadku, gdy początkowy cleanPoczątek wynosił "Rezerwa"
            if (wasRezerwa) {
              tableBody.insertBefore(przejazdRow, nextRow.nextSibling); // Dodaj po currentRow
              rowCount++; // Zwiększamy rowCount, bo dodaliśmy wiersz
              i++; // Zwiększ i, aby pominąć dodany wiersz
            } else {
              tableBody.insertBefore(przejazdRow, nextRow);
              rowCount++; // Zwiększamy rowCount, bo dodaliśmy wiersz
              i++; // Zwiększ i, aby pominąć dodany wiersz
            }

            przejazdRow.style.backgroundColor = "rgba(163, 120, 0)";
          }
        }
      }
    }

    function ZjazdDoZajezdni() {
      // Add the "Zjazd Do Zajezdni" row if needed
      const tableBody = document.querySelector("#rozkładTable tbody");
      if (tableBody.rows.length > 0) {
        const lastRow = tableBody.rows[tableBody.rows.length - 1];
        const beflastRow = tableBody.rows[tableBody.rows.length - 2];
        const KierunekValue = beflastRow.cells[3].innerText.trim();

        // Check if the last row has enough cells (at least 4 cells)
        if (lastRow.cells.length > 3) {
          const lastKierunekValue = lastRow.cells[3].innerText.trim();

          const lastPoczatekValue = lastRow.cells[2].innerText.trim();

          if (lastKierunekValue !== "Lubelska Zajezdnia MPK" && lastPoczatekValue !== "Rezerwa") {
            let zjazdRow = document.createElement("tr");
            let zjazdCell = document.createElement("td");
            zjazdCell.colSpan = 9;
            zjazdCell.innerText = "Zjazd Do Zajezdni";
            zjazdCell.style.textAlign = "center";
            zjazdRow.appendChild(zjazdCell);
            tableBody.appendChild(zjazdRow);
            zjazdRow.style.backgroundColor = "rgba(163, 120, 0)";
          } else if (lastPoczatekValue == "Rezerwa" && KierunekValue !== "Lubelska Zajezdnia MPK") {

            let zjazdRow = document.createElement("tr");
            let zjazdCell = document.createElement("td");
            zjazdCell.colSpan = 9;
            zjazdCell.innerText = "Zjazd Do Zajezdni";
            zjazdCell.style.textAlign = "center";
            zjazdRow.appendChild(zjazdCell);
            tableBody.appendChild(zjazdRow);
            zjazdRow.style.backgroundColor = "rgba(163, 120, 0)";

          }
        }
      }
    }









    // Główna funkcja init()
    async function init() {

      checkLogin();

      loadBrygadaTitle();
      loadBrygadaType();

      let lines = await fetchGOTOWEFile();
      if (lines) {
        await processGOTOWEData(lines);
        ZjazdDoZajezdni();
        WyjazdNaLinie();
        brygadabisowa();
        PrzejazdTechniczny();
        highlightCurrentTimeCells();
        addPodmianaRows();
        checkAndAddRow();


      } else {
        console.error("Nie udało się wczytać GOTOWE.txt.");
      }
    }

  </script>
</body>

</html>
